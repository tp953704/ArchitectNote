# JVM 調效目標
1. 改善JVM應用程式效能
2. 避免導致效能問題的錯誤
3. 確保應用程式在記憶體限制內穩定可靠運行
4. 達到最佳回應速度

## 第一部分：JVM運行機制（第2-3章）
- JVM如何編譯和執行程式碼
- JVM基本內部結構
- 提供基礎理解為後續課程鋪墊

## 第二部分：記憶體管理（第4-10章）
- Java記憶體工作原理
- 堆疊（Stack）和堆積（Heap）的角色
- 記憶體分配機制
- 記憶體管理預設值調整機會

## 第三部分：垃圾回收（第11-15章）
- 最小化垃圾回收需求的程式設計選擇
- 選擇最適合的垃圾回收演算法
- 調整演算法工作方式

## 第四部分：程式碼效能評估（第16-19章）
- 使用分析器（Profiler）找出程式碼問題
- 使用基準測試（Benchmarking）評估不同程式碼選擇
- 使用 JMH（Java Microbenchmark Harness）框架

## 第五部分：程式設計選擇（第20-22章）
- 第20章: 列表（List）集合
- 第21章: 映射（Map）集合
- 第22章: 其他程式設計問題
- StringBuilder 的必要性
- 基本型別 vs 物件效能

## 第六部分：其他JVM語言與未來（第23-24章）
- 第23章: GraalVM 專案（JVM的替代方案）
- 第24章: 評估其他JVM語言（Scala、Kotlin、Groovy、Clojure）與Java的效能比較

# 重要技術細節
## 程式碼快取（Code Cache）
1. 用於存放編譯為原生機器碼的方法
2. 預設大小有限，可能成為效能瓶頸

## 相關JVM參數
```
# 顯示程式碼快取使用情況 推薦值=>總是開啟
-XX:+PrintCodeCache
# 設定初始程式碼快取大小 推薦值=>32m-64m
-XX:InitialCodeCacheSize=<size>
# 設定保留程式碼快取大小（最大值） 推薦值=>128m-512m
-XX:ReservedCodeCacheSize=<size>
# 設定程式碼快取擴充大小 推薦值=>1m-2m
-XX:CodeCacheExpansionSize=<size>
```

## 大小單位
### 位元組：直接數字
KB：數字後加 K（如 256K）
MB：數字後加 M（如 48M）
GB：數字後加 G

### 預設大小
Java 7及以下：32MB（32位元）或 48MB（64位元）
Java 8及以上：最多240MB（64位元JVM）

## 監控工具
### JConsole
- JDK內建監控工具
- 可監控遠端伺服器上的應用程式
- 可查看程式碼快取使用情況隨時間變化

### Windows系統設定注意事項
為了讓JConsole正常運作，需要確保以下資料夾具有寫入權限：
```
%USERPROFILE%\AppData\Local\Temp\hsperfdata_<username>
```

### JConsole使用限制
- 監控本身會使用約2MB的程式碼快取
- 需要應用程式運行足夠長時間以便連接

## 效能優化機會
### 程式碼快取優化
1. 監控是否出現 "code cache is full" 警告
2. 根據應用程式需求調整程式碼快取大小
3. 避免頻繁的編譯和重新編譯循環

### 編譯層級理解
- 了解JVM的分層編譯機制
- 識別哪些方法會被優化到最高層級（Tier 4）
- 合理管理熱點程式碼

## JVM 常見指令範例
1. 單純顯示程式碼快取資訊
```
java -XX:+PrintCodeCache -jar your-app.jar
jcmd <pid> Compiler.codecache
```
2. 設定程式碼快取大小（MB單位）
```
java -XX:+PrintCodeCache -XX:InitialCodeCacheSize=32m -XX:ReservedCodeCacheSize=256m -XX:CodeCacheExpansionSize=1m -jar your-app.jar
```
3. 設定程式碼快取大小（KB單位）
```
java -XX:+PrintCodeCache -XX:InitialCodeCacheSize=32768k -XX:ReservedCodeCacheSize=262144k -XX:CodeCacheExpansionSize=1024k -jar your-app.jar
```
4. 配合其他常用參數
```
java -XX:+PrintCodeCache \
     -XX:InitialCodeCacheSize=64m \
     -XX:ReservedCodeCacheSize=512m \
     -XX:CodeCacheExpansionSize=2m \
     -Xms512m \
     -Xmx2g \
     -jar your-application.jar
```
5. 
```
java -XX:+PrintCodeCache -XX:ReservedCodeCacheSize=28m Main 5000
```
6. 生產環境推薦設定
```
java -XX:+PrintCodeCache \
     -XX:InitialCodeCacheSize=64m \
     -XX:ReservedCodeCacheSize=512m \
     -XX:CodeCacheExpansionSize=2m \
     -XX:+UseCodeCacheFlushing \
     -XX:CICompilerCount=4 \
     -jar production-app.jar
```

## 監控相關指令
### 使用 JConsole 監控
```
# 啟動 JConsole
jconsole

# 或者直接連接到特定 PID
jconsole <pid>

# 查看所有 Code Cache 相關參數
java -XX:+PrintFlagsFinal -version | grep CodeCache
```

# 32位元 vs 64位元 JVM 選擇
## 記憶體考量
- 32位元 JVM：
    - 堆記憶體需求 < 3GB 時可能更快
    - 記憶體指標較小（32位元 vs 64位元），操作更快
    - 總記憶體不得超過 4GB
    - 僅有 Client 編譯器（C1）

- 64位元 JVM：
    - 支援更大記憶體
    - 同時包含 Client 和 Server 編譯器
    - 對於大量使用 long/double 的應用可能更好

- 作業系統限制
    - Mac 和 Sparc：僅支援 64位元 JVM
    - Windows/Linux：可選擇 32位元或 64位元

## 編譯器類型
### Client 編譯器（C1）啟動更快，仍有Tier4編譯
- 適用場景：短生命週期應用（Client應用）
- 特點：啟動速度快，適合快速執行的程式
- 標誌：-client
PS: -XX:TieredStopAtLevel=1 會是更有效更精確編譯層級開關

### Server 編譯器（C2）
- 適用場景：長時間運行應用（Server應用）
- 特點：長期運行效能優化更好
- 標誌：-server（32位元）、-d64（64位元）

### JVM 效能調校參數
1. 分層編譯控制
```
# 關閉分層編譯（僅用解釋模式）
-XX:-TieredCompilation
# 強制使用Client編譯器
-client
# 強制使用Server編譯器
-server
```
2. 編譯器執行緒數量
```
# 查詢當前設定值
jinfo -flag CICompilerCount <pid>
# 設定編譯器執行緒數量（預設通常為3）
-XX:CICompilerCount=6
```
3. 編譯閾值
```
# 查詢編譯閾值
jinfo -flag CompileThreshold <pid>

# 設定方法編譯閾值（預設通常為10000） CompileThreshold => 一個方法被呼叫這麼多次後，就該把它從『解釋執行』編譯成『原生程式碼』了。
-XX:CompileThreshold=1000
```
## 常用診斷工具
1. 查詢所有JVM參數
java -XX:+PrintFlagsFinal -version
2. 查詢特定參數值
```
# 使用jinfo查詢特定參數
jinfo -flag <參數名稱> <pid>
# 範例
jinfo -flag CICompilerCount 10192
jinfo -flag CompileThreshold 10192
```
3. 列出Java程序
```
jps -l
```

## 效能優化建議
1. 應用程式類型考量
- 短生命週期應用：優先考慮 -client 和較低的編譯閾值
- 長時間運行應用：使用標準分層編譯，關注長期效能

2. 硬體環境測試
- 務必在實際部署的硬體上進行效能測試
- 不同硬體環境可能產生截然不同的結果

3. 編譯器調校
- 增加 CICompilerCount 可加速編譯過程
- 降低 CompileThreshold 可讓熱點方法更早被編譯
- 需要通過實際測試驗證效果

### 重要注意事項
1. 平台差異：某些標誌在特定作業系統上可能被忽略
2. 測試重要性：所有優化都應該通過嚴格的基準測試驗證
3. 平衡考量：啟動時間 vs 長期運行效能的權衡
4. 記憶體限制：32位元JVM有4GB記憶體上限

# Stack 與 Heap 筆記
## 記憶體三大區域
- Stack（堆疊）
- Heap（堆積）
- Metaspace（後續章節介紹）
## Stack（堆疊）詳解
### 基本特性
1. 每個執行緒都有自己的 Stack
2. 高效資料結構，由 JVM 有效管理
3. LIFO（後進先出） 結構
4. 自動記憶體管理：Java 確切知道何時銷毀 Stack 上的資料

## Stack 運作方式
```
public class Example {
    public static void main(String[] args) {
        int value = 5;          // 推入 Stack
        int result = calculate(value); // 方法呼叫
        value = result;         // 更新變數
    }                           // Stack 清空
    
    public static int calculate(int data) { // 參數複本推入 Stack
        int temp1 = data * 2;   // 區域變數推入 Stack
        int temp2 = temp1 + 10; // 區域變數推入 Stack
        return temp2;           // 方法結束，所有相關變數彈出 Stack
    }
}
```
### 變數生命週期規則
1. 進入程式區塊（{）：變數推入 Stack
2. 離開程式區塊（}）：變數彈出 Stack
3. 方法結束：所有該方法的區域變數彈出 Stack
4. 執行緒結束：整個 Stack 清空
### Stack 的限制
1. 僅限同執行緒存取
2. 只儲存基本型別和物件參考
3. 無法儲存複雜物件
## Heap（堆積）詳解
### 基本特性
1. 單一 Heap，所有執行緒共享
2. 儲存所有物件實例
3. 需要垃圾回收機制管理
4. 可被應用程式中所有程式區塊存取

### 為什麼需要 Heap？
1. 物件通常較大，不適合 Stack 儲存
2. 物件需要在不同方法間傳遞
3. 避免大量資料複製，提高效率

## Stack vs Heap 儲存規則
### 基本型別（Primitives）
```
int age = 21;        // 完全儲存在 Stack
double salary = 50000; // 完全儲存在 Stack
```
### 物件（Objects）
```
String name = "John"; 
// Stack: name 變數（儲存物件參考/記憶體位址）
// Heap:  "John" 字串物件（實際資料）
```
### 程式碼範例
```
public class MemoryExample {
    public static void main(String[] args) {
        List<String> myList = new ArrayList<>();  // 1. 建立 List
        myList.add("1");                          // 2. 加入字串
        myList.add("2");
        myList.add("3");
        printList(myList);                        // 3. 傳遞 List 給方法
    }
    
    public static void printList(List<String> data) {
        String value = data.get(1);               // 4. 取得元素參考
        data.add("4");                            // 5. 修改原始 List
    }                                             // 6. 方法結束，區域變數彈出
}
#記憶體狀態變化
#步驟 1：建立 List
Stack: myList → Heap: ArrayList物件
#步驟 2：加入字串
Stack: myList → Heap: ArrayList物件 → String "1"
                         ↓
                       String "2"
                         ↓  
                       String "3"
# 步驟 3：方法呼叫
Stack: myList → Heap: ArrayList物件 → String "1"
       data   ↗                    → String "2"
                                 → String "3"
# 步驟 4：取得元素參考
Stack: myList → Heap: ArrayList物件 → String "1"
       data   ↗                    → String "2" ← value
                                 → String "3"
# 步驟 5：加入新元素
Stack: myList → Heap: ArrayList物件 → String "1"
       data   ↗                    → String "2" ← value
                                 → String "3"
                                 → String "4"
# 步驟 6：方法結束
Stack: myList → Heap: ArrayList物件 → String "1"
                                 → String "2"
                                 → String "3"
                                 → String "4"
```
## 重要概念總結
1. 參考傳遞（Pass by Reference）
```
// 傳遞的是物件參考，不是物件複本
modifyList(myList); // 兩個方法操作同一個 List 物件
```
2. 變數範圍（Scoping）
- Stack 變數只在宣告的區塊內可見
- Heap 物件可被多個參考指向
3. 記憶體效率
- 傳遞大型物件時，只需複製參考（4-8 bytes）
- 避免大量資料複製，提高效能

4. 多執行緒影響
- Stack：執行緒安全（每個執行緒獨立）
- Heap：需要同步控制（所有執行緒共享）

# Java 方法參數傳遞與 final 關鍵字筆記
## 方法參數傳遞機制
### 基本型別（Primitives）傳遞
```
public static void main(String[] args) {
    int localValue = 5;
    calculate(localValue);      // 傳遞值的複本
    System.out.println(localValue); // 輸出: 5 (原始值未改變)
}

public static void calculate(int calcValue) {
    calcValue = calcValue * 100; // 只修改複本，不影響原始變數
}
```
### 重要規則
- Java 總是「傳值呼叫」（Pass by Value）
- 基本型別：傳遞值的複本
- 物件型別：傳遞物件參考（reference）的複本
- 沒有「傳參考呼叫」（Pass by Reference） 機制

### 物件參數傳遞詳解
```
public static void main(String[] args) {
    Customer c = new Customer("John");  // 1. 建立 Customer 物件
    renameCustomer(c);                  // 2. 傳遞參考複本
    System.out.println(c.getName());    // 4. 輸出: "Diane"
}

public static void renameCustomer(Customer cust) {
    cust.setName("Diane");              // 3. 修改同一個物件
}
```
### 記憶體狀態變化
```
步驟 1:
Stack: c → Heap: Customer物件 → String "John"

步驟 2-3:
Stack: c → Heap: Customer物件 → String "Diane"
       cust ↗              (原始 "John" 成為垃圾)

步驟 4:
Stack: c → Heap: Customer物件 → String "Diane"
```
### 關鍵理解
- 傳遞的是參考的複本，不是物件的複本
- 兩個參考指向同一個物件
- 透過任一參考修改物件，都會影響原始物件

## final 關鍵字詳解
### 三種使用方式
1. final 變數：只能被賦值一次
2. final 方法：不能被覆寫（override）
3. final 類別：不能被繼承
### final 變數的真相
```
public static void main(String[] args) {
    final Customer c = new Customer("John");  // 合法：第一次賦值
    // c = new Customer("Susan");             // 編譯錯誤：不能重新賦值
    c.setName("Susan");                       // 合法：可以修改物件內容
}
```
### final 的真正意義
1. 不能改變參考指向的物件
2. 可以修改物件的內部狀態
3. 最接近常數，但不是真正的常數

### 安全程式設計建議
1. 方法參數宣告為 final
```
public void processCustomer(final Customer cust) {
    // cust = new Customer();  // 編譯錯誤
    cust.setName("New Name");   // 仍然允許
}
```
2. 遵循封裝原則
    - Getter 方法不應修改狀態
    - 明確區分讀取和修改操作
3. 效能考量
    - final 增加編譯器進行內聯（inlining）優化
    - 對效能有潛在幫助

### 內聯解釋 inlining
1. 是否內聯由 JIT （Just-In-Time）自行決定  
    - JIT 會根據方法大小、呼叫頻率、CPU 架構等多種因素來決定是否內聯。
    - 不一定所有 final 方法都會被內聯；JIT 可能認為某些方法太大或呼叫不頻繁，內聯反而不划算。

2. 例子：HotSpot JIT 的策略
    - 熱點方法（hot method）：頻繁呼叫的方法更容易被內聯。
    - 小方法：短小的方法更容易被內聯。
    - 大型或複雜方法：可能會被部分內聯（partial inlining），或者不內聯。
```
class Example {
    final int add(int a, int b) {
        return a + b;
    }

    int compute() {
        // 這裡原本是呼叫 add(a, b)
        // 內聯後 JIT 會直接把 return a + b; 放在這裡
        return add(2, 3);  
    }
}
```
## 重要概念總結
### 傳值呼叫的影響
    1. 基本型別：方法內修改不影響呼叫端
    2. 物件型別：方法內修改物件狀態會影響呼叫端
    3. 物件參考：方法內重新賦值不影響呼叫端
```
Java 的設計限制
沒有 const correctness 機制
const 是保留字但未實作
需要程式設計師自律確保物件安全
```