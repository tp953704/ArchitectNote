# JVM 調效目標
1. 改善JVM應用程式效能
2. 避免導致效能問題的錯誤
3. 確保應用程式在記憶體限制內穩定可靠運行
4. 達到最佳回應速度

## 第一部分：JVM運行機制（第2-3章）
- JVM如何編譯和執行程式碼
- JVM基本內部結構
- 提供基礎理解為後續課程鋪墊

## 第二部分：記憶體管理（第4-10章）
- Java記憶體工作原理
- 堆疊（Stack）和堆積（Heap）的角色
- 記憶體分配機制
- 記憶體管理預設值調整機會

## 第三部分：垃圾回收（第11-15章）
- 最小化垃圾回收需求的程式設計選擇
- 選擇最適合的垃圾回收演算法
- 調整演算法工作方式

## 第四部分：程式碼效能評估（第16-19章）
- 使用分析器（Profiler）找出程式碼問題
- 使用基準測試（Benchmarking）評估不同程式碼選擇
- 使用 JMH（Java Microbenchmark Harness）框架

## 第五部分：程式設計選擇（第20-22章）
- 第20章: 列表（List）集合
- 第21章: 映射（Map）集合
- 第22章: 其他程式設計問題
- StringBuilder 的必要性
- 基本型別 vs 物件效能

## 第六部分：其他JVM語言與未來（第23-24章）
- 第23章: GraalVM 專案（JVM的替代方案）
- 第24章: 評估其他JVM語言（Scala、Kotlin、Groovy、Clojure）與Java的效能比較

# 重要技術細節
## 程式碼快取（Code Cache）
1. 用於存放編譯為原生機器碼的方法
2. 預設大小有限，可能成為效能瓶頸

## 相關JVM參數
```
# 顯示程式碼快取使用情況 推薦值=>總是開啟
-XX:+PrintCodeCache
# 設定初始程式碼快取大小 推薦值=>32m-64m
-XX:InitialCodeCacheSize=<size>
# 設定保留程式碼快取大小（最大值） 推薦值=>128m-512m
-XX:ReservedCodeCacheSize=<size>
# 設定程式碼快取擴充大小 推薦值=>1m-2m
-XX:CodeCacheExpansionSize=<size>
```

## 大小單位
### 位元組：直接數字
KB：數字後加 K（如 256K）
MB：數字後加 M（如 48M）
GB：數字後加 G

### 預設大小
Java 7及以下：32MB（32位元）或 48MB（64位元）
Java 8及以上：最多240MB（64位元JVM）

## 監控工具
### JConsole
- JDK內建監控工具
- 可監控遠端伺服器上的應用程式
- 可查看程式碼快取使用情況隨時間變化

### Windows系統設定注意事項
為了讓JConsole正常運作，需要確保以下資料夾具有寫入權限：
```
%USERPROFILE%\AppData\Local\Temp\hsperfdata_<username>
```

### JConsole使用限制
- 監控本身會使用約2MB的程式碼快取
- 需要應用程式運行足夠長時間以便連接

## 效能優化機會
### 程式碼快取優化
1. 監控是否出現 "code cache is full" 警告
2. 根據應用程式需求調整程式碼快取大小
3. 避免頻繁的編譯和重新編譯循環

### 編譯層級理解
- 了解JVM的分層編譯機制
- 識別哪些方法會被優化到最高層級（Tier 4）
- 合理管理熱點程式碼

## JVM 常見指令範例
1. 單純顯示程式碼快取資訊
```
java -XX:+PrintCodeCache -jar your-app.jar
jcmd <pid> Compiler.codecache
```
2. 設定程式碼快取大小（MB單位）
```
java -XX:+PrintCodeCache -XX:InitialCodeCacheSize=32m -XX:ReservedCodeCacheSize=256m -XX:CodeCacheExpansionSize=1m -jar your-app.jar
```
3. 設定程式碼快取大小（KB單位）
```
java -XX:+PrintCodeCache -XX:InitialCodeCacheSize=32768k -XX:ReservedCodeCacheSize=262144k -XX:CodeCacheExpansionSize=1024k -jar your-app.jar
```
4. 配合其他常用參數
```
java -XX:+PrintCodeCache \
     -XX:InitialCodeCacheSize=64m \
     -XX:ReservedCodeCacheSize=512m \
     -XX:CodeCacheExpansionSize=2m \
     -Xms512m \
     -Xmx2g \
     -jar your-application.jar
```
5. 
```
java -XX:+PrintCodeCache -XX:ReservedCodeCacheSize=28m Main 5000
```
6. 生產環境推薦設定
```
java -XX:+PrintCodeCache \
     -XX:InitialCodeCacheSize=64m \
     -XX:ReservedCodeCacheSize=512m \
     -XX:CodeCacheExpansionSize=2m \
     -XX:+UseCodeCacheFlushing \
     -XX:CICompilerCount=4 \
     -jar production-app.jar
```

## 監控相關指令
### 使用 JConsole 監控
```
# 啟動 JConsole
jconsole

# 或者直接連接到特定 PID
jconsole <pid>

# 查看所有 Code Cache 相關參數
java -XX:+PrintFlagsFinal -version | grep CodeCache
```

# 32位元 vs 64位元 JVM 選擇
## 記憶體考量
- 32位元 JVM：
    - 堆記憶體需求 < 3GB 時可能更快
    - 記憶體指標較小（32位元 vs 64位元），操作更快
    - 總記憶體不得超過 4GB
    - 僅有 Client 編譯器（C1）

- 64位元 JVM：
    - 支援更大記憶體
    - 同時包含 Client 和 Server 編譯器
    - 對於大量使用 long/double 的應用可能更好

- 作業系統限制
    - Mac 和 Sparc：僅支援 64位元 JVM
    - Windows/Linux：可選擇 32位元或 64位元

## 編譯器類型
### Client 編譯器（C1）啟動更快，仍有Tier4編譯
- 適用場景：短生命週期應用（Client應用）
- 特點：啟動速度快，適合快速執行的程式
- 標誌：-client
PS: -XX:TieredStopAtLevel=1 會是更有效更精確編譯層級開關

### Server 編譯器（C2）
- 適用場景：長時間運行應用（Server應用）
- 特點：長期運行效能優化更好
- 標誌：-server（32位元）、-d64（64位元）

### JVM 效能調校參數
1. 分層編譯控制
```
# 關閉分層編譯（僅用解釋模式）
-XX:-TieredCompilation
# 強制使用Client編譯器
-client
# 強制使用Server編譯器
-server
```
2. 編譯器執行緒數量
```
# 查詢當前設定值
jinfo -flag CICompilerCount <pid>
# 設定編譯器執行緒數量（預設通常為3）
-XX:CICompilerCount=6
```
3. 編譯閾值
```
# 查詢編譯閾值
jinfo -flag CompileThreshold <pid>

# 設定方法編譯閾值（預設通常為10000） CompileThreshold => 一個方法被呼叫這麼多次後，就該把它從『解釋執行』編譯成『原生程式碼』了。
-XX:CompileThreshold=1000
```
## 常用診斷工具
1. 查詢所有JVM參數
java -XX:+PrintFlagsFinal -version
2. 查詢特定參數值
```
# 使用jinfo查詢特定參數
jinfo -flag <參數名稱> <pid>
# 範例
jinfo -flag CICompilerCount 10192
jinfo -flag CompileThreshold 10192
```
3. 列出Java程序
```
jps -l
```

## 效能優化建議
1. 應用程式類型考量
- 短生命週期應用：優先考慮 -client 和較低的編譯閾值
- 長時間運行應用：使用標準分層編譯，關注長期效能

2. 硬體環境測試
- 務必在實際部署的硬體上進行效能測試
- 不同硬體環境可能產生截然不同的結果

3. 編譯器調校
- 增加 CICompilerCount 可加速編譯過程
- 降低 CompileThreshold 可讓熱點方法更早被編譯
- 需要通過實際測試驗證效果

### 重要注意事項
1. 平台差異：某些標誌在特定作業系統上可能被忽略
2. 測試重要性：所有優化都應該通過嚴格的基準測試驗證
3. 平衡考量：啟動時間 vs 長期運行效能的權衡
4. 記憶體限制：32位元JVM有4GB記憶體上限

# Stack 與 Heap 筆記
## 記憶體三大區域
- Stack（堆疊）
- Heap（堆積）
- Metaspace（後續章節介紹）
## Stack（堆疊）詳解
### 基本特性
1. 每個執行緒都有自己的 Stack
2. 高效資料結構，由 JVM 有效管理
3. LIFO（後進先出） 結構
4. 自動記憶體管理：Java 確切知道何時銷毀 Stack 上的資料

## Stack 運作方式
```
public class Example {
    public static void main(String[] args) {
        int value = 5;          // 推入 Stack
        int result = calculate(value); // 方法呼叫
        value = result;         // 更新變數
    }                           // Stack 清空
    
    public static int calculate(int data) { // 參數複本推入 Stack
        int temp1 = data * 2;   // 區域變數推入 Stack
        int temp2 = temp1 + 10; // 區域變數推入 Stack
        return temp2;           // 方法結束，所有相關變數彈出 Stack
    }
}
```
### 變數生命週期規則
1. 進入程式區塊（{）：變數推入 Stack
2. 離開程式區塊（}）：變數彈出 Stack
3. 方法結束：所有該方法的區域變數彈出 Stack
4. 執行緒結束：整個 Stack 清空
### Stack 的限制
1. 僅限同執行緒存取
2. 只儲存基本型別和物件參考
3. 無法儲存複雜物件
## Heap（堆積）詳解
### 基本特性
1. 單一 Heap，所有執行緒共享
2. 儲存所有物件實例
3. 需要垃圾回收機制管理
4. 可被應用程式中所有程式區塊存取

### 為什麼需要 Heap？
1. 物件通常較大，不適合 Stack 儲存
2. 物件需要在不同方法間傳遞
3. 避免大量資料複製，提高效率

## Stack vs Heap 儲存規則
### 基本型別（Primitives）
```
int age = 21;        // 完全儲存在 Stack
double salary = 50000; // 完全儲存在 Stack
```
### 物件（Objects）
```
String name = "John"; 
// Stack: name 變數（儲存物件參考/記憶體位址）
// Heap:  "John" 字串物件（實際資料）
```
### 程式碼範例
```
public class MemoryExample {
    public static void main(String[] args) {
        List<String> myList = new ArrayList<>();  // 1. 建立 List
        myList.add("1");                          // 2. 加入字串
        myList.add("2");
        myList.add("3");
        printList(myList);                        // 3. 傳遞 List 給方法
    }
    
    public static void printList(List<String> data) {
        String value = data.get(1);               // 4. 取得元素參考
        data.add("4");                            // 5. 修改原始 List
    }                                             // 6. 方法結束，區域變數彈出
}
#記憶體狀態變化
#步驟 1：建立 List
Stack: myList → Heap: ArrayList物件
#步驟 2：加入字串
Stack: myList → Heap: ArrayList物件 → String "1"
                         ↓
                       String "2"
                         ↓  
                       String "3"
# 步驟 3：方法呼叫
Stack: myList → Heap: ArrayList物件 → String "1"
       data   ↗                    → String "2"
                                 → String "3"
# 步驟 4：取得元素參考
Stack: myList → Heap: ArrayList物件 → String "1"
       data   ↗                    → String "2" ← value
                                 → String "3"
# 步驟 5：加入新元素
Stack: myList → Heap: ArrayList物件 → String "1"
       data   ↗                    → String "2" ← value
                                 → String "3"
                                 → String "4"
# 步驟 6：方法結束
Stack: myList → Heap: ArrayList物件 → String "1"
                                 → String "2"
                                 → String "3"
                                 → String "4"
```
## 重要概念總結
1. 參考傳遞（Pass by Reference）
```
// 傳遞的是物件參考，不是物件複本
modifyList(myList); // 兩個方法操作同一個 List 物件
```
2. 變數範圍（Scoping）
- Stack 變數只在宣告的區塊內可見
- Heap 物件可被多個參考指向
3. 記憶體效率
- 傳遞大型物件時，只需複製參考（4-8 bytes）
- 避免大量資料複製，提高效能

4. 多執行緒影響
- Stack：執行緒安全（每個執行緒獨立）
- Heap：需要同步控制（所有執行緒共享）

# Java 方法參數傳遞與 final 關鍵字筆記
## 方法參數傳遞機制
### 基本型別（Primitives）傳遞
```
public static void main(String[] args) {
    int localValue = 5;
    calculate(localValue);      // 傳遞值的複本
    System.out.println(localValue); // 輸出: 5 (原始值未改變)
}

public static void calculate(int calcValue) {
    calcValue = calcValue * 100; // 只修改複本，不影響原始變數
}
```
### 重要規則
- Java 總是「傳值呼叫」（Pass by Value）
- 基本型別：傳遞值的複本
- 物件型別：傳遞物件參考（reference）的複本
- 沒有「傳參考呼叫」（Pass by Reference） 機制

### 物件參數傳遞詳解
```
public static void main(String[] args) {
    Customer c = new Customer("John");  // 1. 建立 Customer 物件
    renameCustomer(c);                  // 2. 傳遞參考複本
    System.out.println(c.getName());    // 4. 輸出: "Diane"
}

public static void renameCustomer(Customer cust) {
    cust.setName("Diane");              // 3. 修改同一個物件
}
```
### 記憶體狀態變化
```
步驟 1:
Stack: c → Heap: Customer物件 → String "John"

步驟 2-3:
Stack: c → Heap: Customer物件 → String "Diane"
       cust ↗              (原始 "John" 成為垃圾)

步驟 4:
Stack: c → Heap: Customer物件 → String "Diane"
```
### 關鍵理解
- 傳遞的是參考的複本，不是物件的複本
- 兩個參考指向同一個物件
- 透過任一參考修改物件，都會影響原始物件

## final 關鍵字詳解
### 三種使用方式
1. final 變數：只能被賦值一次
2. final 方法：不能被覆寫（override）
3. final 類別：不能被繼承
### final 變數的真相
```
public static void main(String[] args) {
    final Customer c = new Customer("John");  // 合法：第一次賦值
    // c = new Customer("Susan");             // 編譯錯誤：不能重新賦值
    c.setName("Susan");                       // 合法：可以修改物件內容
}
```
### final 的真正意義
1. 不能改變參考指向的物件
2. 可以修改物件的內部狀態
3. 最接近常數，但不是真正的常數

### 安全程式設計建議
1. 方法參數宣告為 final
```
public void processCustomer(final Customer cust) {
    // cust = new Customer();  // 編譯錯誤
    cust.setName("New Name");   // 仍然允許
}
```
2. 遵循封裝原則
    - Getter 方法不應修改狀態
    - 明確區分讀取和修改操作
3. 效能考量
    - final 增加編譯器進行內聯（inlining）優化
    - 對效能有潛在幫助

### 內聯解釋 inlining
1. 是否內聯由 JIT （Just-In-Time）自行決定  
    - JIT 會根據方法大小、呼叫頻率、CPU 架構等多種因素來決定是否內聯。
    - 不一定所有 final 方法都會被內聯；JIT 可能認為某些方法太大或呼叫不頻繁，內聯反而不划算。

2. 例子：HotSpot JIT 的策略
    - 熱點方法（hot method）：頻繁呼叫的方法更容易被內聯。
    - 小方法：短小的方法更容易被內聯。
    - 大型或複雜方法：可能會被部分內聯（partial inlining），或者不內聯。
```
class Example {
    final int add(int a, int b) {
        return a + b;
    }

    int compute() {
        // 這裡原本是呼叫 add(a, b)
        // 內聯後 JIT 會直接把 return a + b; 放在這裡
        return add(2, 3);  
    }
}
```
## 重要概念總結
### 傳值呼叫的影響
    1. 基本型別：方法內修改不影響呼叫端
    2. 物件型別：方法內修改物件狀態會影響呼叫端
    3. 物件參考：方法內重新賦值不影響呼叫端
```
Java 的設計限制
沒有 const correctness 機制
const 是保留字但未實作
需要程式設計師自律確保物件安全
```

# Java 記憶體管理與逃逸引用筆記

## 逃逸引用 (Escaping References)

### 什麼是逃逸引用？
- 當類別內部私有物件的引用被傳遞到類別外部時發生
- 違反封裝原則，外部代碼可以修改內部狀態
- 導致調試困難，難以追蹤數據被修改的位置

### 問題示例
```java
public class CustomerRecords {
    private Map<String, Customer> records = new HashMap<>();
    
    // 逃逸引用問題！
    public Map<String, Customer> getCustomers() {
        return records; // 返回內部集合的引用
    }
}
```

### 解決方案

#### 1. 實現 Iterable 接口
```java
public class CustomerRecords implements Iterable<Customer> {
    @Override
    public Iterator<Customer> iterator() {
        return records.values().iterator();
    }
}
```
- **性能影響**: 零性能影響
- **缺點**: 仍可通過迭代器的 remove() 方法修改集合

#### 2. 返回集合副本
```java
public Map<String, Customer> getCustomers() {
    return new HashMap<>(records);
}
```
- **性能影響**: 較小
- 複製引用而非對象本身
- 100,000個對象約需複製800KB內存
- 短生命週期對象，垃圾回收效率高

#### 3. 返回不可修改集合 (推薦)
```java
// Java 8及以下
public Map<String, Customer> getCustomers() {
    return Collections.unmodifiableMap(records);
}

// Java 10+
public Map<String, Customer> getCustomers() {
    return Map.copyOf(records);
}
```
- 完全防止外部修改
- 嘗試修改會拋出 UnsupportedOperationException

### 對象級別的逃逸引用

#### 問題示例
```java
public Customer find(String name) {
    return records.get(name); // 返回內部對象引用
}
```

#### 解決方案

##### 1. 複製構造函數
```java
public class Customer {
    public Customer(Customer original) {
        this.name = original.getName();
    }
}

public Customer find(String name) {
    return new Customer(records.get(name));
}
```

##### 2. 使用接口創建只讀視圖 (推薦)
```java
public interface ReadOnlyCustomer {
    String getName();
    String toString();
}

public class Customer implements ReadOnlyCustomer {
    // 實現細節...
}

public ReadOnlyCustomer find(String name) {
    return records.get(name);
}
```
- 編譯時檢查，更安全
- 性能影響小

##### 3. Java 9+ 模塊系統
- 使用模塊系統隱藏實現類
- 只導出接口，不導出實現類
- 完全防止類型轉換繞過保護

## Java 記憶體結構深入

### 元空間 (Metaspace)
- **替代 PermGen**: Java 8+ 取代 PermGen
- **存儲內容**:
  - 類元數據
  - 方法信息
  - 編譯後的代碼
  - 靜態變量

### 靜態變量存儲
```java
static int globalVersion;        // 完全存儲在元空間
static Map<String, String> settings; // 對象在堆，引用在元空間
```

### 重要特性
- 靜態變量永久存在，不會被垃圾回收
- 所有線程共享訪問元空間
- public/private 不影響存儲位置，只影響訪問權限

### JVM 優化

#### 1. 棧上分配
- JVM 檢測不會共享的對象
- 在棧上創建對象，提高性能
- 自動優化，無需程序員干預

#### 2. 字符串池優化
```java
String one = "hello";
String two = "hello";
System.out.println(one == two); // true - 同一個對象
```

#### 字符串駐留 (Interning)
```java
String three = new Integer(76).toString();
String four = "76";
System.out.println(three == four); // false

String five = new Integer(76).toString().intern();
String six = "76";
System.out.println(five == six); // true
```

### 性能要點
- 字符串池從 Java 7 開始位於堆中
- 池中的字符串可以被垃圾回收
- 使用 `intern()` 方法手動駐留字符串
- 適用於頻繁重複的字符串場景
### 逃逸引用最佳實踐
1. **優先使用不可修改集合**
2. **使用接口提供只讀視圖**
3. **考慮使用複製構造函數**
4. **Java 9+ 使用模塊系統加強保護**

### 性能考慮
- 避免逃逸引用的性能影響通常很小
- 短生命週期對象對垃圾回收友好
- JVM 會自動進行多種優化
- 在性能關鍵代碼中選擇零性能影響的解決方案

# Java 記憶體調優與 JVM 參數設定

## 字符串池 (String Pool) 優化

### 字符串池工作原理
- 使用 HashMap 實現，包含多個桶(buckets)
- 默認桶數量：60,013 個（Java 8+）
- 字符串根據 hash code 分配到對應的桶中
- 相同 hash code 的字符串會進入同一個桶

### 性能問題
- 桶數量過少 → 每個桶中字符串過多
- 查找效率降低（需要遍歷桶中所有字符串）
- 插入新字符串時需要檢查桶中是否已存在

### 監控字符串池統計信息
```bash
java -XX:+PrintStringTableStatistics Main
```

**輸出解讀：**
```
StringTable statistics:
Number of buckets       : 60013
Number of entries       : 731
Average bucket size     : 0.01
Maximum bucket size     : 2
```

### 調整字符串池大小
```bash
# 設置字符串池桶數量（建議使用質數）
java -XX:StringTableSize=120121 Main
```

**性能改善示例：**
- 調整前：49秒，平均桶大小 166
- 調整後：28秒，平均桶大小 83
- 記憶體增加：僅 0.5MB

**建議：**
- 當平均桶大小 > 40-50 時考慮調整
- 使用質數作為桶數量以獲得更好的散列分布

## 堆記憶體 (Heap) 調優

### 查看默認堆設置
```bash
java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal | grep Heap
```

**重要參數：**
- `MaxHeapSize`：最大堆大小（默認約 4GB）
- `InitialHeapSize`：初始堆大小（默認約 260MB）

### 設置堆大小
```bash
# 完整語法
java -XX:MaxHeapSize=2g -XX:InitialHeapSize=1g Main

# 簡寫語法（更常用）
java -Xmx2g -Xms1g Main
```

### 性能考慮
- **設置較大初始堆**：避免運行時動態擴展，提升性能
- **設置適當最大堆**：確保應用有足夠記憶體，但不要過大
- **注意**：遇到 OutOfMemoryError 時不應簡單增加堆大小，可能存在記憶體洩漏問題

## 實際調優示例

### 測試代碼
```java
public class Main {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        List<String> strings = new ArrayList<>();
        
        for (int i = 0; i < 10_000_000; i++) {
            String str = String.valueOf(i).intern();
            strings.add(str); // 保持引用，防止被GC
        }
        
        long end = System.currentTimeMillis();
        System.out.println("Elapsed time: " + (end - start) + "ms");
    }
}
```

### 綜合調優命令
```bash
# 綜合優化：字符串池 + 堆記憶體
java -XX:StringTableSize=120121 -Xms1g -Xmx2g -XX:+PrintStringTableStatistics Main
```

## 調優建議總結

### 字符串池調優
1. **監控**：定期檢查字符串池統計信息
2. **調整時機**：當平均桶大小 > 40-50 時
3. **數值選擇**：使用質數，通常為默認值的 2-4 倍

### 堆記憶體調優
1. **初始堆大小**：設置為應用正常運行所需的大小
2. **最大堆大小**：根據可用物理記憶體設置
3. **測試驗證**：使用較小堆測試應用穩定性

### 性能監控要點
- 使用 `-XX:+PrintStringTableStatistics` 監控字符串池
- 使用 `-XX:+PrintFlagsFinal` 查看所有JVM參數
- 關注GC日誌和記憶體使用模式

## 注意事項

### 版本兼容性
- `PrintStringTableStatistics` 在 OpenJDK 11 中存在bug
- 建議使用 Java 8 或 Java 12+ 進行字符串池調優測試

### 調優原則
1. **測量為先**：不要盲目調優，先收集數據
2. **漸進調整**：每次只調整一個參數，觀察效果
3. **生產驗證**：在測試環境驗證後再應用於生產環境

根據你提供的課程內容，我整理了關於 Java 垃圾回收（Garbage Collection）的詳細筆記：

## Java 垃圾回收機制筆記

### 🎯 核心概念

#### 記憶體管理特點
- **自動管理**：Java 是託管語言（managed language），程式員不需要手動釋放物件記憶體
- **與 C/C++ 對比**：
  - C/C++ 需要手動呼叫 `free()` 或設定變數為 `null`
  - Java 由 JVM 自動判斷物件何時不再需要

#### 記憶體洩漏（Memory Leak）
- **傳統語言問題**：未釋放記憶體會導致系統記憶體逐漸耗盡
- **Java 的解決方案**：
  1. JVM 控制記憶體請求與釋放
  2. 垃圾回收機制自動清理不再使用的物件

### 🔍 垃圾回收判定規則

#### 資格條件
```java
// 物件符合垃圾回收條件：無法從 stack 透過 reference 到達
Object obj = new Object();  // 有引用 → 不是垃圾
obj = null;                 // 失去引用 → 成為垃圾
```

#### 重要概念
- **可達性（Reachability）**：從 stack 或 metaspace（靜態變數）能否訪問到物件
- **循環引用**：即使物件互相引用，如果無法從 stack 訪問，仍會被回收
- **集合物件**：當集合本身成為垃圾時，其中的所有元素也會成為垃圾

### ⚡ 垃圾回收控制

#### System.gc() 方法
```java
System.gc();  // 只是「建議」JVM 執行垃圾回收，非強制命令
```

**注意事項**：
- 不保證立即執行垃圾回收
- 通常不建議手動呼叫，因為：
  - 垃圾回收會消耗系統資源
  - 可能暫停應用程式執行
  - JVM 的自動調優通常更有效

#### Java 8 vs Java 11 差異
- **Java 8**：堆記憶體大小只增不減
- **Java 11**：垃圾回收後可能歸還記憶體給作業系統
- **效能優化**：可使用 `-Xms` 設定初始堆大小

### ⚠️ finalize() 方法（已棄用）

#### 方法特性
```java
@Override
protected void finalize() throws Throwable {
    // 物件被垃圾回收時會呼叫
    System.out.println("物件被垃圾回收");
}
```

#### 棄用原因
1. **執行時機不確定**：無法保證何時執行
2. **可能永遠不執行**：程式結束時 JVM 可能直接退出
3. **效能問題**：可能阻礙垃圾回收流程
4. **資源清理風險**：不應用於關閉資源等關鍵操作

#### 實驗證明
- 在 finalize() 中加入無窮迴圈會導致垃圾回收卡住
- 只有部分物件的 finalize() 被執行，數量不確定

### 💡 最佳實踐

1. **信任 JVM**：讓垃圾回收器自動管理，避免手動干預
2. **避免使用 finalize()**：Java 9+ 已正式棄用
3. **理解可達性**：專注於確保物件在需要時保持可訪問
4. **效能測試**：不要依賴 System.gc() 進行效能評測

### 🔄 垃圾回收流程總結

1. **建立物件** → 堆記憶體分配
2. **失去引用** → 成為垃圾回收候選
3. **JVM 決定時機** → 執行垃圾回收
4. **清理記憶體** → 回收不可達物件

這套機制確保 Java 應用程式在大多數情況下不會出現系統級的記憶體洩漏問題，讓開發者能更專注於業務邏輯而非記憶體管理。