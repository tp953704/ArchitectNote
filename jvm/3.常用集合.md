# Java List 類型性能分析 - 中文筆記

## 課程重點概述
第五部分課程探討程式碼選擇對應用程式性能的影響，本章專注於Java中不同List類型的運作原理和性能表現。

## Java中的八種List實現

### 主要關注的四種類型：
1. **ArrayList** - 最常用的List類型
2. **LinkedList** - 鏈結串列實現
3. **Vector** - 線程安全的ArrayList
4. **Stack** - 繼承自Vector（不推薦使用）

### 特殊用途類型（通常忽略）：
- AttributeList - 用於MBean物件
- RoleList, RoleUnresolvedList - 用於管理Role物件
- CopyOnWriteArrayList - 特定多線程場景使用

## ArrayList 深度解析

### 內部實現機制：
- 使用**陣列**作為底層存儲
- 初始容量：**10個元素**
- 當陣列滿時會自動擴容：
  - 新容量 = 舊容量 + 舊容量/2
  - 例如：10 → 15 → 22 → 33...

### 性能優化技巧：
```java
// 預設構造函數 - 可能導致多次擴容
List<Book> books = new ArrayList<>();

// 優化構造函數 - 指定初始容量
List<Book> books = new ArrayList<>(500000);
```

### 實測結果：
- 添加1000萬本書籍：
  - 無初始容量：約6600毫秒
  - 指定初始容量：約3300毫秒（性能提升約50%）

## Vector 類別分析

### 與ArrayList的區別：
1. **歷史因素**：Vector是Java 1.0的原始集合類型
2. **線程安全**：Vector是線程安全的
3. **性能成本**：線程安全帶來性能開銷

### 使用建議：
- 在多線程環境中可考慮使用
- 非多線程環境建議使用ArrayList

## LinkedList 內部機制

### 節點結構：
每個節點包含三個指針：
- **中間指針**：指向實際物件
- **前指針**：指向前一個節點
- **後指針**：指向下一個節點

### 內存管理：
- 無需預先分配內存空間
- 動態添加/移除節點
- 通過指針維護元素順序

## 性能比較與選擇指南

### 添加元素性能：
- **結尾添加**：
  - ArrayList：快速（除非需要擴容）
  - LinkedList：總是快速
- **開頭添加**：
  - ArrayList：需要移動所有元素（性能差）
  - LinkedList：只需更新指針（性能優）

### 檢索元素性能：
```java
// 實測結果（檢索中間位置元素）：
// ArrayList：約1毫秒
// LinkedList：約125毫秒
```
- **ArrayList**：直接通過索引訪問（O(1)）
- **LinkedList**：需要遍歷節點（O(n)）

### 刪除元素性能：
- **開頭刪除**：LinkedList性能更好
- **中間刪除**：ArrayList可能更好（無需遍歷）

### 排序性能：
- 兩者都使用Arrays.sort()
- LinkedList需要先轉換為陣列，性能略差

## 實用建議總結

### 使用ArrayList的場景：
- 頻繁隨機訪問元素
- 已知大致容量時指定初始大小
- 大部分添加操作在列表末尾

### 使用LinkedList的場景：
- 頻繁在列表開頭或中間添加/刪除元素
- 主要進行順序訪問而非隨機訪問
- 需要實現棧或隊列功能

### 多線程環境選擇：
1. **Vector** - 傳統線程安全方案
2. **CopyOnWriteArrayList** - 讀多寫少場景
3. **ArrayList + 同步塊** - 自定義同步控制

## 源代碼查看技巧
- JDK源代碼位置：`JDK目錄/lib/src.zip`
- 可查看ArrayList.java等核心類的實現細節
- 有助於深入理解Java集合框架的運作原理

# Java Map 類型性能分析 - 中文筆記

## Map 基本概念
- Map 由鍵(key)和值(value)組成
- 每個鍵對應唯一的值，鍵不能重複
- **關鍵特性**：檢索時間與Map大小無關，10個項目 vs 10億個項目檢索時間相同

## HashMap 內部實現機制

### 初始結構
- 初始容量：**16個桶(bucket)**
- 每個桶是一個鏈表

### 存儲過程
1. **計算哈希值**：將鍵轉換為整數（hashCode）
2. **計算桶位置**：`hashCode % 桶數量`
3. **存儲到對應桶**的鏈表中

### 擴容機制
- **負載因子(Load Factor)**：預設 0.75（75%）
- 當使用率達到負載因子時，容量**翻倍**
- 擴容時所有元素需要重新計算位置

### 性能優化配置
```java
// 指定初始容量和負載因子
Map<Integer, Book> books = new HashMap<>(500000, 0.6f);

// 僅指定初始容量
Map<Integer, Book> books = new HashMap<>(500000);
```

### 實測結果（添加1000萬本書）：
- 無參數構造：約6.7秒
- 初始容量50萬：約4.7秒
- 初始容量50萬 + 負載因子0.9：約3.7秒
- 初始容量1000萬 + 負載因子0.6：最快

## 自定義對象作為鍵的關鍵問題

### hashCode() 方法的重要性
- 如果所有對象hashCode相同，所有元素會進入同一個桶
- 導致單個鏈表極長，性能急劇下降

### hashCode() 和 equals() 規則
1. **分散性**：不同對象應產生不同的hashCode
2. **一致性**：相等對象必須有相同hashCode

### 優化hashCode實現
```java
// 複雜但分散性好的實現（Eclipse生成）
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + id;
    result = prime * result + ((author == null) ? 0 : author.hashCode());
    // ... 其他字段
    return result;
}

// 簡單高效的實現（僅使用ID）
@Override
public int hashCode() {
    return id;
}
```

## 其他Map類型比較

### LinkedHashMap
- **特性**：保持元素插入順序
- **實現**：在HashMap基礎上增加雙向鏈表
- **性能**：檢索性能與HashMap相同，內存占用稍多
- **使用場景**：需要保持插入順序時

### HashTable
- **歷史**：Java 1.0的舊實現
- **特性**：線程安全
- **性能**：比HashMap差（同步開銷）
- **建議**：非多線程環境使用HashMap

### TreeMap
- **特性**：按鍵的自然順序排序
- **性能**：檢索性能比HashMap差
- **使用場景**：需要排序且數據量較小

## 性能優化總結

### 容量配置策略
- **初始容量**：根據預期數據量設置，避免頻繁擴容
- **負載因子**：根據讀寫比例調整
  - 讀多寫少：較低負載因子（更多桶，更短鏈表）
  - 寫多讀少：較高負載因子（減少擴容次數）

### hashCode優化原則
1. **計算效率**：盡量簡單快速
2. **分散性**：確保對象均勻分布到不同桶
3. **一致性**：與equals()方法保持一致

### 選擇指南
- **一般情況**：HashMap
- **需要保持順序**：LinkedHashMap  
- **多線程環境**：測試比較HashMap+同步 vs HashTable
- **需要排序**：TreeMap（僅用於小數據集）

## 參考資源
- Stack Overflow關於HashMap性能的詳細分析
- JDK源代碼：`src.zip`中的HashMap實現
# Java 編程選擇與性能優化 - 中文筆記

## 本章重點概述
探討四種常見編程選擇對性能的影響：
1. 基本類型 vs 包裝類對象
2. BigDecimal 性能問題
3. StringBuilder 與字符串拼接
4. 傳統循環 vs Java 8 Streams
5. 日誌記錄的性能考慮

## 1. 基本類型 vs 包裝類對象

### 測試場景：
- 對100萬個long數值進行加法運算
- 比較基本類型long vs 包裝類Long的性能

### 測試結果：
- **基本類型long**：約8毫秒
- **包裝類Long**：約15毫秒

### 結論：
- 基本類型的數學運算性能明顯優於包裝類
- 原因：避免對象創建和垃圾回收開銷

## 2. BigDecimal 性能分析

### 測試場景：
- 對100萬個數值進行加法運算
- 比較BigDecimal vs Double對象的性能

### 測試結果：
- **Double對象**：約28-48毫秒
- **BigDecimal（整數）**：約36毫秒
- **BigDecimal（小數）**：約84毫秒

### 重要發現：
- BigDecimal的精度處理帶來顯著性能開銷
- 即使處理整數，BigDecimal仍比Double慢

### 使用建議：
- 只有在真正需要高精度計算時使用BigDecimal
- 考慮使用double或float替代

## 3. StringBuilder 與字符串拼接

### 測試場景：
- 生成50萬個隨機名字（字符串拼接）
- 比較三種實現方式

### 測試結果：
- **傳統字符串拼接**：約323毫秒
- **StringBuilder**：約181毫秒
- **單行字符串拼接**：約181毫秒（與StringBuilder相當）

### 關鍵發現：
- **JVM優化**：單行字符串拼接會被編譯器自動優化為StringBuilder
- 多行拼接需要手動使用StringBuilder

### 最佳實踐：
```java
// 推薦：單行拼接（自動優化）
String result = firstName + " " + lastName + " " + color;

// 或多行時使用StringBuilder
StringBuilder sb = new StringBuilder();
sb.append(firstName).append(" ").append(lastName).append(" ").append(color);
```

## 4. 傳統循環 vs Java 8 Streams

### 測試場景：
- 處理50萬個名字，過濾長度≥9的名字並計算總長度
- 比較四種實現方式

### 測試結果：
- **傳統循環**：約46毫秒
- **順序Stream**：約52-68毫秒
- **複雜Stream轉換**：約174毫秒（性能最差）
- **並行Stream**：約23毫秒（性能最佳）

### 性能比較：
| 實現方式 | 性能 | 代碼複雜度 |
|---------|------|-----------|
| 傳統循環 | 好 | 簡單 |
| 順序Stream | 中等 | 中等 |
| 複雜Stream | 差 | 複雜 |
| 並行Stream | 最佳 | 中等 |

### 使用建議：
- **並行Stream**：在有多核CPU且任務可並行時性能最佳
- **傳統循環**：簡單場景下性能穩定
- 避免過度複雜的Stream轉換操作

## 5. 日誌記錄的性能優化

### 問題代碼示例：
```java
try {
    // 業務邏輯
} catch (Exception e) {
    // 性能問題：即使日誌級別不夠，仍會執行所有方法調用
    logger.info("Error for user: " + getCurrentUser() + 
                " on terminal: " + getCurrentTerminal() + 
                " processing: " + e.getMessage());
}
```

### 性能問題：
- 即使日誌級別設置為不輸出INFO，仍會執行：
  - `getCurrentUser()`
  - `getCurrentTerminal()`
  - 字符串拼接
- 造成不必要的CPU和內存開銷

### 優化方案：
```java
try {
    // 業務邏輯
} catch (Exception e) {
    // 優化：先檢查日誌級別
    if (logger.isLoggable(Level.INFO)) {
        logger.info("Error for user: " + getCurrentUser() + 
                    " on terminal: " + getCurrentTerminal() + 
                    " processing: " + e.getMessage());
    }
}
```

### 最佳實踐：
- 在日誌消息需要複雜計算或方法調用時，始終使用級別檢查
- 避免在日誌語句中直接進行昂貴的操作

## 總結與實用建議

### 性能優化優先級：
1. **基本類型優先**：盡量使用基本類型而非包裝類
2. **精度需求評估**：只在必要時使用BigDecimal
3. **字符串處理**：使用StringBuilder或單行拼接
4. **循環與Stream**：根據場景選擇，並行Stream在合適場景下性能最佳
5. **日誌優化**：添加級別檢查避免不必要的計算

### 測試方法論：
- 使用簡單的基準測試比較不同實現
- 注意JVM的熱身效應（warm-up）
- 對於生產環境，建議使用JMH等專業基準測試工具

# GraalVM 與 Java 性能優化未來 - 中文筆記

## GraalVM 項目概述

### 基本介紹
- **開發狀態**：目前為開發項目，**非生產就緒**
- **支持平台**：僅限 Linux 和 Mac（Windows 支持有限）
- **項目性質**：Oracle 開發的替代 JVM，旨在提供更好性能

### 三項核心功能
1. **替代 JVM**：運行 Java 字節碼的替代虛擬機
2. **替代編譯器**：提供替代的 Java 編譯器
3. **原生編譯**：將 Java 代碼編譯為原生機器碼（**最令人興奮的功能**）

## 環境準備與安裝

### 系統要求
- Linux 或 Mac 操作系統
- Windows 用戶可選：
  - Windows 10：啟用 WSL（Windows Subsystem for Linux）
  - 虛擬機：安裝 VirtualBox + Ubuntu

### 安裝步驟
1. 下載 GraalVM Community Edition
2. 解壓縮檔案：`tar -xzvf graalvm-*.tar.gz`
3. 設置環境路徑

### 驗證安裝
```bash
# 標準 OpenJDK
java -version

# GraalVM 版本
/path/to/graalvm/bin/java -version
```

## 性能測試實驗

### 測試代碼說明
- **功能**：生成隨機 UUID，轉換為數字，尋找最大質數
- **規模**：處理 500,000 個 UUID
- **測試方法**：比較不同運行環境的執行時間

### 測試結果比較

| 運行環境 | 平均執行時間 | 性能對比 |
|---------|-------------|----------|
| OpenJDK 11 | 12,473ms | 基準 |
| OpenJDK 8 | 稍長 | 略慢於 JDK 11 |
| GraalVM VM + OpenJDK 編譯 | 略有改善 | 輕微提升 |
| GraalVM VM + GraalVM 編譯 | 進一步改善 | 更好性能 |
| **原生編譯** | **~11,000ms** | **最佳性能** |

### 關鍵發現
- GraalVM 虛擬機和編譯器都能帶來性能提升
- 組合使用 GraalVM 編譯和運行時效果最佳
- 原生編譯提供最顯著的性能改善

## 原生編譯（Native Image）

### 功能特點
- 將 Java 字節碼編譯為**原生機器碼**
- **無需 JVM** 即可運行
- 生成獨立可執行文件

### 安裝依賴
```bash
sudo apt-get install gcc
sudo apt-get install zlib1g-dev
```

### 編譯過程
```bash
# 編譯為原生可執行文件
/path/to/graalvm/bin/native-image Main

# 運行生成的可執行文件
./main
```

### 原生編譯優勢
- **啟動速度**：顯著加快
- **內存占用**：包含完整 VM，但運行時更高效
- **部署便利**：無需安裝 JRE

## OpenJDK 中的 Graal 功能

### 實驗性功能
- OpenJDK 11+ 已包含部分 Graal 功能
- 僅限 Linux 版本
- 需要手動啟用

### 啟用命令
```bash
java -XX:+UnlockExperimentalVMOptions \
     -XX:+EnableJVMCI \
     -XX:+UseJVMCICompiler \
     Main
```

### 當前限制
- OpenJDK 中的版本較舊
- 性能不如完整 GraalVM
- 仍處於實驗階段

## 技術優勢與未來展望

### GraalVM 的技術優勢
1. **Java 編寫的 VM**：便於維護和改進
2. **更好的優化**：替代 C2 編譯器
3. **快速迭代**：開發周期更短

### 應用場景建議
- **實驗環境**：可嘗試使用
- **生產環境**：目前不推薦（自行承擔風險）
- **未來跟進**：密切關注項目發展

## 重要注意事項

### 兼容性問題
- GraalVM 目前基於 Java 8
- 運行 Java 9+ 代碼需要重新編譯
- 確保編譯和運行環境一致

### 性能測試建議
- 多次運行取平均值
- 考慮 JVM 熱身效應
- 使用專業基準測試工具（如 JMH）

## 總結
GraalVM 代表了 Java 性能優化的未來方向，特別是原生編譯技術有望徹底改變 Java 應用的部署和運行方式。雖然目前仍處於開發階段，但值得開發者密切關注和實驗。隨著技術的成熟，這些功能有望逐步集成到標準 JDK 中，為 Java 生態帶來持續的性能提升。