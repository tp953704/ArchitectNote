## Rust：所有權（Ownership）整理筆記

這份筆記整理 Rust 的核心概念「所有權（ownership）」，以中文 Markdown 呈現並附上可複製的範例程式碼，方便學習與實驗。

---

## 目錄（建議）
- 什麼是所有權？
- 所有權的三個規則
- 移動（move）與複製（copy）
- 借用（borrowing）與參考（references）
  - 不可變借用
  - 可變借用
- 生命週期（lifetimes）概念
- 常見錯誤與陷阱
- 範例集合（可直接執行）
- 小結與建議

---

## 什麼是所有權？

所有權是 Rust 最重要的安全與記憶體管理機制之一。它透過編譯期規則在不使用垃圾回收器的情況下，保證記憶體安全與避免資料競爭。

簡單來說：每個值在同一時間內有且只有一個所有者（owner）；當所有者離開作用域（scope）時，該值會被自動釋放（drop）。

---
## Rust：所有權（Ownership） — 統整筆記

整理後的版本，把原檔內重複與零散段落合併為清晰的章節，保留並整理所有程式範例。內容以中文呈現，程式碼可複製至 Rust 專案測試。

---

## 目錄

- 什麼是所有權（Ownership）
- 所有權的三條規則
- 堆（Heap）與棧（Stack）簡介
- Move / Copy / Clone
- 借用（Borrowing）與參考（References）
  - 不可變借用（&T）
  - 可變借用（&mut T）
- 生命週期（Lifetimes）概要
- 切片（Slices）簡要
- 所有權與函數的互動（傳參 / 回傳）
- 常見錯誤範例與解法
- 範例集中（可直接執行）
- 小結與後續建議

---

## 什麼是所有權？

所有權是 Rust 的核心記憶體管理機制。每個值同一時間只有一個擁有者（變數），當擁有者超出作用域時，該值會自動被釋放（drop）。這個設計讓 Rust 在編譯期能保證記憶體安全，而不需要垃圾回收器。

---

## 所有權的三條規則

1. 每個值都有一個所有者變數。
2. 一次只能有一個所有者。
3. 當所有者超出作用域時，值會被釋放（drop）。

掌握這三條規則能幫助理解後續的 move、borrow、lifetime 等行為。

---

## 堆（Heap）與棧（Stack）簡介

- 棧（stack）：快速分配、編譯期大小已知，函數回收時自動清理。適合儲存具固定大小的值（如整數、指標結構）。
- 堆（heap）：動態分配，大小於執行期決定，需由擁有者釋放（Rust 在擁有者 drop 時自動處理）。

例如 `String` 在堆上儲存資料，而其結構（指標、長度、容量）存在棧上。

---

## Move / Copy / Clone

- Move：非 Copy 型別（如 `String`, `Vec<T>`）賦值或傳入函數會發生 move，原變數失效。
- Copy：實作 `Copy` trait 的型別（整數、bool、帶 Copy 的元組等）賦值為複製，原變數仍可用。
- Clone：對非 Copy 型別要保留原變數，需呼叫 `.clone()` 做深拷貝（有成本）。

範例：

```rust
fn main() {
    // Move
    let s1 = String::from("hello");
    let s2 = s1; // s1 moved to s2
    // println!("{}", s1); // error: value used after move

    // Copy
    let x = 5;
    let y = x; // i32 is Copy
    println!("x = {}, y = {}", x, y);

    // Clone
    let a = String::from("hi");
    let b = a.clone();
    println!("a = {}, b = {}", a, b);
}
```

---

## 借用（Borrowing）與參考（References）

借用讓你在不取得所有權的情況下使用資料。分為不可變借用（&T）和可變借用（&mut T）。

重要規則：同一時間要麼有任意多個不可變借用，要麼有一個可變借用（兩者不能同時存在）。

### 不可變借用（&T）

```rust
fn main() {
    let s = String::from("hello");
    let r1 = &s;
    let r2 = &s; // 多個不可變借用允許
    println!("{} and {}", r1, r2);
}
```

### 可變借用（&mut T）

```rust
fn change(s: &mut String) {
    s.push_str(", world");
}

fn main() {
    let mut s = String::from("hello");
    change(&mut s); // 傳入可變引用
    println!("s = {}", s);
}
```

若嘗試同時建立不可變借用與可變借用，會在編譯時被拒絕（E0502）。

---

## 生命週期（Lifetimes）概要

生命週期描述引用有效的範圍。編譯器會在大多數情況下自動推導生命週期，但複雜情況（例如回傳引用）需要顯式註記 `<'a>`。

錯誤示範（不可返回指向局部變數的引用）：

```rust,compile_fail
fn bad() -> &String {
    let s = String::from("hello");
    &s // error: returns reference to local variable
}
```

解法通常是回傳擁有者（例如 `String`）或使用生命週期參數使引用的生命週期與輸入參考綁定。

---

## 切片（Slices）簡要

切片是對集合（陣列、字串、向量）連續範圍的引用，不會複製資料。

```rust
fn main() {
    let s = String::from("hello, world");
    let hello = &s[0..5];
    let world = &s[7..12];
    println!("{}, {}", hello, world);
}
```

切片遵守借用規則：同一時間只能有一個可變切片或任意多個不可變切片。

---

## 所有權與函數的互動

- 傳入函數：若傳入非 Copy 型別，會 move（轉移所有權）。
- 傳入引用：使用 `&T` / `&mut T` 可避免 move。
- 回傳所有權：函數可以回傳擁有者，以將所有權傳回給呼叫者。

範例（傳入/回傳）：

```rust
fn takes_ownership(s: String) {
    println!("took: {}", s);
}

fn makes_copy(x: i32) {
    println!("copied: {}", x);
}

fn gives_ownership() -> String {
    String::from("hello")
}

fn takes_and_gives_back(s: String) -> String {
    s
}

fn main() {
    let s = String::from("hi");
    takes_ownership(s);

    let x = 5;
    makes_copy(x);

    let s1 = gives_ownership();
    let s2 = takes_and_gives_back(s1);
    println!("s2 = {}", s2);
}
```

---

## 常見錯誤範例與解法

- 使用被 move 的變數 -> 檢查是否需要 `.clone()` 或傳入引用。
- 同時有可變借用與其他借用 -> 調整作用域或重構以分離借用時間。
- 返回指向局部變數的引用（懸垂引用） -> 改用回傳擁有者或使用正確的生命週期註記。

---

## 範例集中（可直接執行）

1) Move 範例

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // move
    println!("s2 = {}", s2);
}
```

2) Borrow 範例

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);
    println!("len = {}", len);
}
```

3) 可變借用範例

```rust
fn change(s: &mut String) {
    s.push_str(" world");
}

fn main() {
    let mut s = String::from("hello");
    change(&mut s);
    println!("s = {}", s);
}
```

4) 生命週期錯誤示範（編譯錯誤）

```rust,compile_fail
fn bad() -> &i32 {
    let x = 5;
    &x // error: borrowed value does not live long enough
}
```

---

## 小結與後續建議

- 所有權、借用與生命週期合力讓 Rust 在編譯期保證記憶體安全。
- 建議做法：多試、讀編譯錯誤訊息（compiler messages 很有教學價值），嘗試把範例改寫成借用/回傳不同組合來理解行為。
- 可延伸：深入生命週期註記、借用檢查器（borrow checker）常見錯誤解析、RAII 與 Drop 的進階應用、效能與 clone 使用策略。

