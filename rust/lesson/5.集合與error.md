# 集合（Collections）與錯誤處理（Error Handling）

這份筆記整理了 Rust 常用的集合（Array / Slice / Vec / String / HashMap）、迭代器、以及錯誤處理（Option / Result / panic）等主題；保留簡潔範例並給出預期輸出提示，方便貼到 playground 或專案測試。

---

## 目錄

- 概覽（Array / Slice / Vec / String / HashMap）
- 迭代器與常見操作（map / filter / collect / enumerate）
- 集合使用注意（所有權、借用、索引 vs get）
- 錯誤類型：Option / Result / panic
- 錯誤傳播：`?` 與 match
- 自訂錯誤與整合（From / thiserror / anyhow）
- 日誌（log / env_logger / slog）簡介
- 範例集合（可執行）
- 小結與建議

---

## 概覽

- Array: 固定長度，型別 `[T; N]`。
- Slice: `&[T]` 或 `&mut [T]`，對陣列或 Vec 的區段借用。
- Vec<T>: 動態大小的堆上陣列，最常用集合。
- String / &str: `&str` 為字串切片（借用），`String` 擁有與可變。
- HashMap<K, V>: 鍵值對集合，需 `use std::collections::HashMap`。

選型要點：若大小固定用 Array；需動態增刪用 Vec；需要鍵查詢用 HashMap；字串資料注意所有權與編碼（UTF-8）。

---

## Vec 與常見操作（重點）

- 建立：`let v = vec![1,2,3];` 或 `Vec::new()`。
- 修改：`push`, `pop`, `insert`, `remove`。
- 存取：`v[i]`（越界 panic）或 `v.get(i)`（回傳 Option）。
- 迭代：`for x in &v`（不可變借用）、`for x in &mut v`（可變借用）、`v.into_iter()`（取得所有權）。

範例：

```rust
fn main() {
    let mut v = vec![1, 2, 3];
    v.push(4);
    println!("v = {:?}", v); // v = [1, 2, 3, 4]

    if let Some(third) = v.get(2) {
        println!("third = {}", third); // third = 3
    }
}
```

注意：將 Vec 賦值給新變數會移動所有權（若元素不可 Copy）；若要共用請用借用 `&v`。

---

## HashMap（重點）

- 建立：`let mut m = HashMap::new();`
- 插入/更新：`insert`（覆蓋）或 `entry(key).or_insert(val)`（僅鍵不存在時插入）。
- 存取：`m.get(&k)` → `Option<&V>`；`m[&k]` 會在鍵不存在時 panic。

範例（詞頻）：

```rust
use std::collections::HashMap;

fn main() {
    let text = "hello world hello";
    let mut counts = HashMap::new();
    for w in text.split_whitespace() {
        *counts.entry(w).or_insert(0) += 1;
    }
    println!("counts = {:?}", counts); // counts = {"hello":2, "world":1}
}
```

提示：若鍵使用 `String`，插入時會移動字串；用 `&str` 作鍵則須保證被借用的來源存活。

---

## 迭代器與常用方法

- `iter()`, `iter_mut()`, `into_iter()`。
- 組合函式：`map`, `filter`, `collect`, `enumerate`, `fold`。

範例：

```rust
fn main() {
    let v = vec![1,2,3,4,5];
    let even: Vec<i32> = v.iter().filter(|&&x| x % 2 == 0).cloned().collect();
    println!("even = {:?}", even); // [2,4]
}
```

注意：`iter()` 回傳 `&T`；若需要取得值（非引用），可用 `cloned()` 或 `copied()`。

---

## 錯誤處理基礎：Option / Result / panic

- Option<T>: Some(T) 或 None，用於表示可能不存在的值。
- Result<T, E>: Ok(T) 或 Err(E)，用於可能失敗的操作（I/O、解析等）。
- panic!: 不可恢復錯誤，會造成程式中止；測試或不可恢復情況才用。

範例（Option）：

```rust
fn find_first_even(v: &[i32]) -> Option<i32> {
    v.iter().cloned().find(|x| x % 2 == 0)
}
```

範例（Result + `?`）：

```rust
use std::fs;
use std::io;

fn read_file(path: &str) -> Result<String, io::Error> {
    fs::read_to_string(path) // ? 可在呼叫處使用
}
```

---

## 錯誤傳播：`?` 與 match

- `?` 在函式回傳 `Result` 或 `Option` 時，會在遇到 Err/None 時提早回傳。
- 若需轉換錯誤型別，可實作 `From<OtherError> for MyError`。

範例（示意）：

```rust
fn foo() -> Result<i32, String> {
    let a = bar()?; // 若 bar() 回傳 Err，立即返回
    Ok(a + 1)
}
```

當需要更細緻處理時，使用 `match` 顯式處理分支。

---

## panic! 與使用時機

- `panic!` 使程式中止（展開或 abort，可於 Cargo profile 調整）。
- 建議：盡量用 `Result`/`Option` 做可恢復錯誤處理；僅對不可恢復錯誤或原型使用 `panic!`。

---

## 自訂錯誤與實務（簡介）

- 通常以 `enum` 定義自訂錯誤，實作 `Display` 與 `std::error::Error`。
- `thiserror` 可用宏簡化定義；`anyhow` 適合快速聚合錯誤（應用層）。

簡短示意（thiserror）：

```rust
// Cargo.toml: thiserror = "1"
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Parse error: {0}")]
    Parse(String),
}
```

---

## 日誌（簡述）

- 輕量：`log` + `env_logger`（通過 RUST_LOG 控制等級）。
- 生產：`slog` 支援結構化、非同步日誌。

示例（env_logger）：

```rust
// Cargo.toml: log = "0.4", env_logger = "0.10"
use log::info;

fn main() {
    env_logger::init();
    info!("app started");
}
```

執行：
RUST_LOG=info cargo run

---

## 範例（可直接執行）

1) Vec 基本

```rust
fn main() {
    let mut v = vec![1,2,3];
    v.push(4);
    println!("last = {:?}", v.pop()); // Some(4)
}
```

2) HashMap 詞頻（見上方）

3) Result 傳播（檔案讀取）

```rust
use std::fs;
use std::io;

fn read_file(path: &str) -> Result<String, io::Error> {
    fs::read_to_string(path)
}

fn main() {
    match read_file("./Cargo.toml") {
        Ok(s) => println!("len={}", s.len()),
        Err(e) => eprintln!("err={}", e),
    }
}
```

---

## 小結與建議

- 已把檔案整理為單一結構：集合 / 迭代器 / 錯誤 / 日誌，移除重複與雜訊段落。
- 如果你要我接下來做：
  1. 補上每個範例的實際預期輸出並執行驗證（我可以替你 run 小範例並把結果寫回）。
  2. 加入 `thiserror` / `anyhow` 的實務範例並示範 Cargo.toml。 
  3. 匯出為 PDF/投影片（需安裝 pandoc 或其他工具，我可以示範命令）。

歡迎告訴我你要的下一步（例如：「補預期輸出」或「新增 thiserror 範例」），我會接著處理。
# 集合（Collections）與錯誤處理（Error Handling）

這份筆記以中文 Markdown 整理 Rust 常用的集合類型與錯誤處理模式，並提供簡短可執行範例，方便直接貼到專案或 playground 試驗。

---

## 目錄
# 集合（Collections）與錯誤處理（Error Handling）

此檔為整理後的筆記，聚焦常用集合（Vec/HashMap/Array/String）、迭代器與錯誤處理（Option/Result/panic），並保留可直接執行的簡潔範例與預期輸出說明。

---

## 目錄

- 概覽（Array / Slice / Vec / String / HashMap）
- 迭代器與常見操作（map / filter / collect / enumerate）
- 常用集合實作與注意（所有權、借用、索引 vs get）
- 錯誤類型：Option / Result / panic
- 錯誤傳播：`?` 與 match、常見技巧
- 自訂錯誤與整合（From、thiserror/anyhow 簡介）
- 日誌（log / env_logger / slog）快速參考
- 範例（Vec / HashMap / Result 傳播 / 自訂 Error）
- 小結與延伸建議

---

## 概覽

- Array: 固定大小，類型為 `[T; N]`。
- Slice: `&[T]` 或 `&mut [T]`，是對陣列或 Vec 的連續區段參考。
- Vec<T>: 動態陣列，堆上儲存，最常用的集合。
- String / &str: `&str` 為字串切片（借用），`String` 可擁有與修改。
- HashMap<K, V>: 鍵值表，需 `use std::collections::HashMap`。

注意：選擇集合時考量大小是否固定、是否需動態增刪、以及對索引/查詢的需求。

---

## Vec 與常見操作

- 建立：`Vec::new()` 或 `vec![1,2,3]`。
- 新增/刪除：`push`, `pop`, `insert`, `remove`。
- 存取：`v[i]`（索引，越界會 panic），或 `v.get(i)`（回傳 Option）。
- 迭代：`for x in &v`（不可變借用）、`for x in &mut v`（可變借用）、`v.into_iter()`（取得所有權）。

範例：

```rust
fn main() {
    let mut v = vec![1, 2, 3];
    v.push(4);
    println!("v = {:?}", v); // v = [1,2,3,4]

    // 安全存取
    if let Some(third) = v.get(2) {
        println!("third = {}", third);
    }
}
```

預期輸出（示意）：
v = [1, 2, 3, 4]
third = 3

注意：當向量被移動（let v2 = v;）後，原變數不可再使用；若只讀用請傳借用（&v）。

---

## HashMap 快速參考

- 建立：`let mut map = HashMap::new();`
- 插入/更新：`insert`（會覆蓋），或 `entry(key).or_insert(value)`（僅在不存在時插入）。
- 存取：`map.get(&k)` 回傳 `Option<&V>`；`map[&k]` 索引會在不存在時 panic。
- 遍歷：`for (k, v) in &map { ... }`。

範例（詞頻）：

```rust
use std::collections::HashMap;

fn main() {
    let text = "hello world hello";
    let mut counts = HashMap::new();
    for w in text.split_whitespace() {
        *counts.entry(w).or_insert(0) += 1;
    }
    println!("counts = {:?}", counts);
}
```

預期輸出（示意，順序不定）：
counts = {"hello": 2, "world": 1}

注意所有權：`HashMap<String, V>` 插入 `String::from("...")` 會移動字串；若用 `&str` 作鍵，須確保被借用的資料存活。

---

## 迭代器（Iterator）與常見組合

- 常用方法：`iter()`, `iter_mut()`, `into_iter()`。
- 函式鏈：`map`, `filter`, `collect`, `enumerate`, `fold`。

範例：

```rust
fn main() {
    let v = vec![1,2,3,4,5];
    let even: Vec<i32> = v.iter().filter(|&&x| x%2==0).cloned().collect();
    println!("even = {:?}", even); // even = [2,4]
}
```

注意：`iter()` 回傳 `&T`，若要擷取值需 `cloned()` 或 `copied()`（元素實現 Copy 時）。

---

## 錯誤類型：Option / Result / panic

- Option<T>: 表示可能有或沒有值（Some / None）。
- Result<T, E>: 成功為 Ok(T)，失敗為 Err(E)，用於可恢復錯誤（I/O、解析等）。
- panic!: 不可恢復錯誤（程式終止），僅在不可恢復情況或原型時使用。

範例（Option）:

```rust
fn find_first_even(v: &[i32]) -> Option<i32> {
    v.iter().cloned().find(|x| x%2==0)
}
```

範例（Result + `?`）:

```rust
use std::fs;
use std::io;

fn read_file(path: &str) -> Result<String, io::Error> {
    let s = fs::read_to_string(path)?; // 若失敗會自動傳回 Err
    Ok(s)
}
```

---

## 錯誤傳播：`?` 與 match

- `?` 可在返回 `Result` 或 `Option` 的函數中快速傳播錯誤（或 None）：相當於遇 Err 即 `return Err(...)`。
- 若需自訂錯誤轉換，實作 `From` trait 可配合 `?` 使用。

範例（等價示意）：

```rust
fn foo() -> Result<i32, String> {
    let a = bar()?; // 若 bar() 回傳 Err，立即返回
    Ok(a+1)
}
```

等同於用 `match` 顯式處理。

---

## panic! 與不可恢復錯誤

- `v[i]` 越界會 panic，`unwrap()` 在 None/Err 時會 panic。
- 生產環境可在 `Cargo.toml` 設定 release profile 的 panic 行為：

```toml
[profile.release]
panic = 'abort' # 或 'unwind'
```

建議：盡量用 `Result`/`Option` 做可恢復錯誤處理，將 `panic!` 保留給真正不可恢復的情況。

---

## 自訂錯誤與整合（簡介）

- 常以 `enum` 定義自訂錯誤並實作 `Display`、`std::error::Error`。
- 若要將多種底層錯誤合併，實作 `From<OtherError> for MyError`，即可在使用 `?` 時自動轉換。
- 常用第三方 crates：
  - `thiserror`：用宏簡化自訂錯誤定義。
  - `anyhow`：方便的錯誤聚合（適合應用層）。

簡短範例（thiserror 用法示意，放於 Cargo 專案中）：

```rust
// Cargo.toml: thiserror = "1"
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Parse error: {0}")]
    Parse(String),
}
```

---

## 日誌（log / env_logger / slog）快速參考

- 輕量：`log` + `env_logger`，程式內呼叫 `info!`, `warn!`, `error!`；以環境變數 `RUST_LOG` 控制等級。
- 生產等級：`slog` 可做結構化日誌（JSON），搭配非同步 drain 提升效能。

示例（env_logger）：

```rust
// Cargo.toml: log = "0.4", env_logger = "0.10"
use log::{info, warn};

fn main() {
    env_logger::init();
    info!("app started");
}
```

執行：
RUST_LOG=info cargo run

---

## 範例集合（快速檢視）

1) Vec 基本

```rust
fn main() {
    let mut v = vec![1,2,3];
    v.push(4);
    println!("last = {:?}", v.pop()); // Some(4)
}
```

2) HashMap 詞頻

（見上方 HashMap 範例）

3) Result 傳播（檔案讀取）

```rust
use std::fs;
use std::io;

fn read_file(path: &str) -> Result<String, io::Error> {
    fs::read_to_string(path)
}

fn main() {
    match read_file("./Cargo.toml") {
        Ok(s) => println!("len={}", s.len()),
        Err(e) => eprintln!("err={}", e),
    }
}
```

4) 自訂錯誤（簡短）

```rust
use std::fmt;

#[derive(Debug)]
enum CustomError { NotFound }

impl fmt::Display for CustomError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, "Not found") }
}

impl std::error::Error for CustomError {}
```


## 日誌（Logging）

日誌是觀察程式行為、除錯與運維的關鍵。以下節以實務角度整理常用套件、設定範例與最佳實踐，方便直接套用在 Cargo 專案中。

### 為何要記錄日誌
- 偵錯：顯示程式在執行什麼操作，協助定位問題。  
- 監控：在生產環境觀察服務狀態與錯誤率。  
- 審計：保留重要操作痕跡（注意隱私與合規）。  
- 效能分析：記錄耗時以找出瓶頸。

### 簡單入門：`log` + `env_logger`
適合開發與輕量服務。將下列依賴加到 `Cargo.toml`：

```toml
[dependencies]
log = "0.4"
env_logger = "0.10"
```

範例：

```rust
use log::{debug, error, info, warn};

fn main() {
    env_logger::init();
    info!("app started");
    warn!("a warning");
    error!("an error");
    debug!("debug details: {}", 42);
}
```

執行時用 `RUST_LOG` 控制等級，例如：

```bash
RUST_LOG=info cargo run
RUST_LOG=debug cargo run
```

輸出範例（format 會依 env_logger 版本略有不同）：
```
2025-10-26T12:00:00Z INFO  my_crate] app started
2025-10-26T12:00:00Z WARN  my_crate] a warning
```

### 進階：結構化日誌（`slog`）
適合生產、高吞吐或需要機器可讀（JSON）日誌的場合。加入依賴：

```toml
[dependencies]
slog = "2"
slog-async = "2"
slog-term = "2"
slog-json = "2"
```

簡單範例（終端輸出 + 非同步）：

```rust
use slog::{info, o, Drain, Logger};
use slog_async;
use slog_term;

fn main() {
    let decorator = slog_term::TermDecorator::new().build();
    let drain = slog_term::FullFormat::new(decorator).build().fuse();
    let drain = slog_async::Async::new(drain).build().fuse();
    let log = Logger::root(drain, o!());

    info!(log, "app started"; "version" => "1.0.0");
}
```

要輸出 JSON 可用 `slog_json`，將 `Drain` 換成 JSON 寫入到檔案或 stdout，即方便後續集中式分析。

### 實務建議與最佳實踐
- 只記錄必要且不敏感的資訊（不要在日誌中寫入密碼或長期憑證）。
- 使用合適的等級（error/warn/info/debug/trace），生產預設通常為 info 或 warn。  
- 在高頻路徑避免昂貴的日誌格式化（或使用 lazy logging / 先判斷等級）。
- 使用非同步日誌（例如 `slog_async`）以降低日誌對主流程的影響。  
- 若需集中管理，輸出 JSON 並使用 log aggregator（如 ELK/Fluentd/Vector）。
- 實作日誌輪轉（log rotation）與保留策略以避免磁碟耗盡。

### 小結
本節示範了從簡單到進階的日誌策略：開發時用 `log`+`env_logger` 快速上手；生產環境可使用 `slog` 或其他結構化日誌方案配合非同步與 JSON 輸出。務必注意不要將敏感資訊寫入日誌，並根據服務需求選擇合適的等級與輸出格式。