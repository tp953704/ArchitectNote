Crates 簡介
歡迎閱讀這篇關於 Rust crate 的深入文章。本文將探討 crate 的核心概念，討論其重要性，並指導您如何有效地建立和管理 crate。在本教程結束時，您將了解 crate 在 Rust 中的工作原理，並學習組織 Rust 專案的最佳實踐。

套件 (crate) 是 Rust 程式的基本建構塊。本質上，套件 (crate) 是一個編譯單元，即 Rust 編譯器能夠獨立編譯的最小程式碼片段。套件 (crate) 是二進位專案和函式庫專案的基礎。讓我們來探討一下套件 (crate) 如此重要的關鍵因素：

板條箱的關鍵方面
板條箱作為編譯單元
在 Rust 中，每個程式至少由一個 crate 組成。每個 crate 由 Rust 編譯器獨立編譯，產生可執行檔（二進位 crate）或函式庫檔（庫 crate）。

依賴管理
板條箱 (crate) 也是依賴管理的主要單元。在 Rust 專案中使用外部函式庫意味著需要將其他板條箱合併為相依性。

模組化和可重複使用性
將程式碼組織到 crate 中可以提升模組化、可重複使用性和可維護性。您可以將 crate 視為可在多個專案之間共用的獨立模組或函式庫。

該圖是一張標題為「Crate 的重要性」的圖表，突出了三個關鍵方面：編譯單元、依賴管理以及模組化和可重用性。

---
title: "6. 包 (Package)、模組 (Module) 與 Crate（整理筆記）"
author: "整理者"
date: 2025-10-26
---

## 摘要

本筆記整理 Rust 中的核心概念：crate（板條箱）、package（套件）、module（模組）與 workspace（工作區）。內容包含定義、建立範例、相依管理（Cargo）、模組檔案結構、可見性（pub）、以及實作範例與最佳實務提示，方便快速查閱與實作。

## 目錄

- Crate 與 Package 概念
- 建立與管理二進位與函式庫 Crate
- 相依管理（Cargo / regex 範例）
- Package、Workspace 與多 crate 組織
- 模組（mod）基礎與檔案布局
- 可見性、use、路徑（crate / super / 相對 / 絕對）
- re-export（pub use）與最佳實務
- 範例程式碼與常用命令

---

## Crate 與 Package（概念）

- Crate：Rust 的編譯單位。可分為二進位 crate（binary，含 `main()`）與函式庫 crate（library，輸出 `lib`，使用 `lib.rs`）。
- Package：包含 1 個或多個 crate 的集合，由 `Cargo.toml` 管理。Package 可以有最多一個 library crate，並可含多個 binary crate。

重要觀念：crate 是編譯與相依管理的基本單位；package 則是以 `Cargo.toml` 為中心的封裝。

---

## 建立二進位與函式庫 Crate（快速步驟）

1. 建立二進位 crate：

```bash
cargo new my_crate_demo
cd my_crate_demo
cargo run --quiet
```

src/main.rs 範例：

```rust
fn main() {
    println!("Hello, world!");
}
```

2. 建立函式庫 crate：

```bash
cargo new --lib text_magic
cd text_magic
cargo build
```

src/lib.rs 範例（反轉字串 / 判斷回文）：

```rust
pub fn reverse(input: &str) -> String {
    input.chars().rev().collect()
}

pub fn is_palindrome(input: &str) -> bool {
    let cleaned: String = input
        .chars()
        .filter(|c| c.is_alphanumeric())
        .collect::<String>()
        .to_lowercase();
    cleaned == reverse(&cleaned)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_reverse() {
        assert_eq!(reverse("hello"), "olleh");
    }

    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("A man, a plan, a canal, Panama"));
        assert!(!is_palindrome("Rustacean"));
    }
}
```

注意：library crate 沒有 `main`，所以不能使用 `cargo run`，要用 `cargo test` 或用其他 binary crate 引入。

---

## 相依管理：Cargo 與外部 crate（以 regex 為例）

- 手動在 `Cargo.toml` 新增相依：

```toml
[dependencies]
regex = "1.11.0"
```

- 或使用命令：

```bash
cargo add regex
```

簡單範例（驗證 Email）：

```rust
use regex::Regex;

fn main() {
    let email = "example@example.com";
    let re = Regex::new(r"^[\w.%+-]+@[\w.-]+\.[a-zA-Z]{2,}$").unwrap();
    println!("'{}' is valid: {}", email, re.is_match(email));
}
```

執行：

```bash
cargo run --quiet
```

---

## Package 與 Workspace（多 crate 管理）

- Workspace 可讓多個 package 共用同一個 target 目錄，方便管理大型專案。

範例 `Cargo.toml`（workspace 根目錄）：

```toml
[workspace]
members = [
  "package1",
  "package2",
]
```

建立子 package：

```bash
cargo new package1
cargo new package2
cargo build      # 在 workspace 根目錄下建置所有 package
```

若要針對特定 package 建置/執行：

```bash
cargo build -p package1
cargo run -p package1
```

---

## 模組（module）基礎

- 在同一檔案內定義模組（inline）:

```rust
mod math {
    pub fn add(a: i32, b: i32) -> i32 { a + b }
    pub fn subtract(a: i32, b: i32) -> i32 { a - b }
}

fn main() {
    println!("{}, {}", math::add(5,3), math::subtract(5,3));
}
```

- 將模組拆成檔案：在 `src/math.rs` 放模組內容，並在 `main.rs` 宣告 `mod math;`。

- 目錄模組：可在 `src/math/mod.rs` 放主模組，再用子檔 `src/math/operations.rs` 或 `src/math/operations/mod.rs`。

檔案解析原則（簡化）：
- `mod foo;` 會找 `foo.rs` 或 `foo/mod.rs`。

---

## 可見性（visibility）、use、路徑

- 預設為 private；使用 `pub` 將 item 暴露給外部。例：`pub fn foo()`。
- `use` 可把路徑引入當前作用域以簡化呼叫：`use crate::math::operations::{self, add};`
- `as` 可建立別名，以避免命名衝突：`use crate::math::utils::add as utils_add;`

路徑類型：
- 絕對路徑：從 crate 根（`crate::...` 或 crate 名稱）開始。
- 相對路徑：由當前模組向下導航。
- `super` 往上移動一層模組層次。

re-export（重新導出）：

```rust
mod math {
    pub mod operations {
        pub fn multiply(a: i32, b: i32) -> i32 { a * b }
    }
    pub use operations::multiply; // 重新導出
}

fn main() {
    println!("{}", math::multiply(3,4));
}
```

---

## 常見範例：模組分離與深度結構

目錄結構範例：

```
src/
├── main.rs
└── math/
    ├── mod.rs         # pub mod operations;
    └── operations/
        ├── mod.rs     # pub mod advanced;
        └── advanced.rs
```

呼叫：`math::operations::advanced::square(3)`。

---

## 最佳實務與注意事項

- 群組相關功能到同一模組（cohesion）。
- 避免過深的模組巢狀（可讀性）。
- 使用 `pub use` 對外暴露穩定 API，內部實作保持 private。
- 小心使用 glob import（`*`），會增加命名衝突風險。

---

## 快速參考命令

```bash
cargo new <name>            # 建立 binary（預設）
cargo new --lib <name>      # 建立 library
cargo build                 # 建置
cargo run                   # 執行 binary
cargo test                  # 進行測試
cargo add <crate>           # 新增相依（需 cargo-edit）
```

---

## 小結

這份整理把原始筆記中的內容凝練成章節化的 Markdown，便於查閱與教學使用。若要我進一步：

- 可以把每個範例拆成獨立的 Git 範例專案（包含 Cargo.toml 與檔案結構）。
- 或把內容轉為簡短投影片（如 README + 範例程式碼）。

需要我把任一範例建立成可執行專案並在本機跑一次嗎？
