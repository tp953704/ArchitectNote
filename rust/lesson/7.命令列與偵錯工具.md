# Rust 命令列與偵錯工具完整筆記

## 摘要

本筆記系統性整理 Rust 偵錯、日誌、命令列工具（CLI）與相關生態系的完整知識體系，包含：IDE 偵錯設定、LLDB/GDB 使用技巧、println 與 logging 系統、Rust 專用調試工具、Clap CLI 框架實作，以及 Docker API 整合的完整範例。

## 目錄

1. [偵錯基礎與工具選擇](#偵錯基礎與工具選擇)
2. [IDE 偵錯環境設定](#ide-偵錯環境設定)
3. [println! 與日誌系統](#println-與日誌系統)
4. [Rust 專用偵錯工具](#rust-專用偵錯工具)
5. [CLI 工具開發與 Clap](#cli-工具開發與-clap)
6. [Docker CLI 整合實作](#docker-cli-整合實作)
7. [最佳實踐與命令總覽](#最佳實踐與命令總覽)

---

## 偵錯基礎與工具選擇

### 為何需要在 Rust 中進行偵錯

儘管 Rust 提供強大的編譯時檢查，下列情況仍需執行時偵錯：

- **邏輯錯誤**：演算法實現錯誤
- **邊界條件**：陣列越界、整數溢位
- **並發問題**：資料競爭、死鎖
- **第三方庫互動**：不預期的庫行為
- **效能瓶頸**：記憶體使用、CPU 佔用

### 偵錯工具選擇策略

```rust
// 偵錯流程建議：
// 1. 快速定位：使用 println! 進行初步問題定位
// 2. 系統化記錄：使用 log + env_logger 進行結構化日誌
// 3. 深度分析：使用 LLDB/GDB 進行執行時分析
// 4. 驗證修正：編寫單元測試鎖定修復

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_factorial() {
        assert_eq!(factorial(5), 120);
    }
}
```

---

## IDE 偵錯環境設定

### VS Code 偵錯設定

`.vscode/launch.json` 配置：

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Rust Debug",
            "type": "lldb",
            "request": "launch",
            "program": "${workspaceFolder}/target/debug/${workspaceFolderBasename}",
            "args": [],
            "cwd": "${workspaceFolder}",
            "sourceLanguages": ["rust"],
            "preLaunchTask": "cargo build"
        }
    ]
}
```

### 必要擴展套件

- **rust-analyzer**：語言伺服器
- **CodeLLDB**：LLDB 偵錯器整合
- **Cargo**：建置與測試工具

---

## println! 與日誌系統

### 基礎 println! 使用

```rust
fn debug_quick_check() {
    let data = vec![1, 2, 3, 4, 5];
    println!("Data length: {}", data.len()); // 快速檢查
    println!("Data: {:?}", data); // Debug trait 輸出
    dbg!(&data); // 更詳細的除錯輸出，包含檔案和行號
}
```

### 結構化日誌系統

**Cargo.toml 依賴：**
```toml
[dependencies]
log = "0.4"
env_logger = "0.10"
chrono = "0.4"
```

**完整日誌實作：**
```rust
use std::fs::OpenOptions;
use std::io::Write;
use env_logger::Builder;
use chrono::Local;
use log::{debug, error, info, warn, LevelFilter};

fn setup_logging() {
    let file = OpenOptions::new()
        .create(true)
        .write(true)
        .append(true)
        .open("output.log")
        .expect("Failed to open log file");

    Builder::new()
        .filter(None, LevelFilter::Debug)
        .format(|buf, record| {
            writeln!(
                buf,
                "{} [{}] - {}",
                Local::now().format("%Y-%m-%d %H:%M:%S"),
                record.level(),
                record.args()
            )
        })
        .target(env_logger::Target::Pipe(Box::new(file)))
        .init();
}

fn main() {
    setup_logging();
    
    info!("Application started");
    
    let config_loaded = false;
    if !config_loaded {
        warn!("Configuration not loaded; using defaults");
    }
    
    let result = divide(10, 0);
    match result {
        Ok(value) => info!("Division successful: {}", value),
        Err(e) => error!("Failed to divide: {}", e),
    }
    
    debug!("Application finished");
}

fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("Division by zero"))
    } else {
        Ok(a / b)
    }
}
```

### 日誌等級分類

| 等級 | 使用場景 | 範例 |
|------|----------|------|
| error! | 嚴重錯誤，應用無法恢復 | error!("Database connection failed") |
| warn! | 潛在問題，但不影響執行 | warn!("Using default configuration") |
| info! | 一般資訊性消息 | info!("Server started on port 8080") |
| debug! | 詳細偵錯資訊 | debug!("Processing user ID: {}", user_id) |
| trace! | 最詳細的追蹤資訊 | trace!("Entering function process_data") |

---

## Rust 專用偵錯工具

### Rust LLDB 基礎使用

```rust
// 有錯誤的階乘函數（用於偵錯示範）
fn factorial_bug(n: u32) -> u32 {
    if n <= 1 {
        1
    } else {
        n * factorial_bug(n + 1)  // Bug: 應該是 n - 1
    }
}

// 修正後的版本
fn factorial_correct(n: u32) -> u32 {
    if n <= 1 {
        1
    } else {
        n * factorial_correct(n - 1)  // 正確：n - 1
    }
}

fn main() {
    let number = 5;
    let result = factorial_correct(number);
    println!("The factorial of {} is {}", number, result);
}
```

### LLDB 偵錯會話範例

```bash
# 編譯帶有偵錯資訊的程式
cargo build

# 啟動 Rust LLDB
rust-lldb target/debug/your_project_name

# LLDB 常用命令
(lldb) breakpoint set --name factorial_bug    # 在函數設定斷點
(lldb) breakpoint set --line 5                # 在特定行設定斷點
(lldb) run                                    # 啟動程式
(lldb) print n                                # 檢查變數值
(lldb) step                                   # 單步執行
(lldb) continue                               # 繼續執行
(lldb) thread backtrace                       # 顯示呼叫堆疊
```

### 偵錯技巧與模式

```rust
// 條件式偵錯輸出
#[cfg(debug_assertions)]
fn debug_helper() {
    println!("[DEBUG] This only prints in debug mode");
}

// 使用 assert! 進行防禦性程式設計
fn process_data(data: &[i32]) -> Option<i32> {
    assert!(!data.is_empty(), "Data should not be empty");
    Some(data.iter().sum())
}

// 自訂 Debug 實現
use std::fmt;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Point({}, {})", self.x, self.y)
    }
}
```

---

## CLI 工具開發與 Clap

### 基礎 CLI 專案設定

**Cargo.toml:**
```toml
[package]
name = "my_cli_tool"
version = "0.1.0"
edition = "2021"

[dependencies]
clap = { version = "4.5", features = ["derive"] }
```

### 基本參數解析

```rust
use clap::Parser;

/// 簡單的問候程式
#[derive(Parser)]
#[command(name = "greeter")]
#[command(about = "一個簡單的 CLI 工具來問候人們", long_about = None)]
struct Cli {
    /// 要問候的人的名字
    #[arg(short, long)]
    name: String,

    /// 自訂問候訊息
    #[arg(short, long, default_value_t = String::from("Hello"))]
    greeting: String,

    /// 以大寫形式列印問候語
    #[arg(short, long, action = clap::ArgAction::SetTrue)]
    uppercase: bool,
}

fn main() {
    let args = Cli::parse();

    let mut message = format!("{} {}", args.greeting, args.name);
    if args.uppercase {
        message = message.to_uppercase();
    }
    println!("{}!", message);
}
```

### 子命令實作

```rust
use clap::{Parser, Subcommand};

/// 帶有子命令的 CLI 工具來問候人們
#[derive(Parser)]
#[command(name = "greeter")]
#[command(about = "一個 CLI 工具來問候人們", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// 向某人問好
    Hello {
        #[arg(short, long)]
        name: String,
    },
    /// 向某人道別
    Goodbye {
        #[arg(short, long)]
        name: String,
    },
    /// 計算數字的階乘
    Factorial {
        #[arg(short, long)]
        number: u32,
    },
}

fn main() {
    let args = Cli::parse();

    match args.command {
        Commands::Hello { name } => println!("Hello, {}!", name),
        Commands::Goodbye { name } => println!("Goodbye, {}!", name),
        Commands::Factorial { number } => {
            let result = factorial_correct(number);
            println!("The factorial of {} is {}", number, result);
        }
    }
}
```

### 進階 CLI 功能

```rust
use clap::{Parser, Subcommand, ValueEnum};

/// 進階 CLI 工具範例
#[derive(Parser)]
#[command(version, about, long_about = None)]
struct AdvancedCli {
    /// 輸出格式
    #[arg(short, long, value_enum, default_value_t = Format::Text)]
    format: Format,
    
    /// 日誌等級
    #[arg(short, long, value_enum, default_value_t = LogLevel::Info)]
    log_level: LogLevel,
    
    #[command(subcommand)]
    command: AdvancedCommands,
}

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
enum Format {
    Text,
    Json,
    Yaml,
}

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
enum LogLevel {
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

#[derive(Subcommand)]
enum AdvancedCommands {
    /// 處理數據
    Process {
        /// 輸入文件
        input: String,
        /// 輸出文件
        #[arg(short, long)]
        output: Option<String>,
    },
    /// 生成報告
    Report {
        /// 報告類型
        #[arg(short, long)]
        report_type: String,
    },
}

fn main() {
    let args = AdvancedCli::parse();
    
    // 根據選擇的格式和日誌等級處理命令
    match args.command {
        AdvancedCommands::Process { input, output } => {
            println!("Processing {} -> {:?}", input, output);
        }
        AdvancedCommands::Report { report_type } => {
            println!("Generating {} report", report_type);
        }
    }
}
```

---

## Docker CLI 整合實作

### 專案結構與依賴

**Cargo.toml:**
```toml
[package]
name = "mydocker"
version = "0.1.0"
edition = "2021"

[dependencies]
bollard = "0.18"  # Docker API 整合
clap = { version = "4.5", features = ["derive"] }  # CLI 解析
tokio = { version = "1.0", features = ["full"] }  # 非同步運行時
futures-util = "0.3"  # 非同步工具
```

**專案結構：**
```
src/
├── main.rs
├── cli.rs
└── docker.rs
```

### CLI 定義模組

**src/cli.rs:**
```rust
use clap::{Parser, Subcommand};

/// mydocker 的頂層 CLI 結構
#[derive(Parser)]
#[command(name = "mydocker")]
#[command(about = "使用 Rust 建置的最小化 Docker CLI")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Command,
}

/// 應用程式的主要命令
#[derive(Subcommand)]
pub enum Command {
    /// 列出 Docker 資源
    List {
        /// 指定列出資源的子命令
        #[command(subcommand)]
        list_command: ListCommands,
    },
    /// 啟動容器
    Start {
        /// 容器名稱或 ID
        container_name: String,
    },
    /// 停止容器
    Stop {
        /// 容器名稱或 ID
        container_name: String,
    },
    /// 從註冊表拉取 Docker 鏡像
    Pull {
        /// 鏡像名稱（例如 nginx:latest）
        image_name: String,
    },
}

/// list 命令的子命令
#[derive(Subcommand)]
pub enum ListCommands {
    /// 列出容器
    Containers {
        /// 包含已停止的容器（預設僅顯示運行中的容器）
        #[arg(short, long)]
        all: bool,
    },
    /// 列出鏡像
    Images,
}
```

### Docker 客戶端模組

**src/docker.rs:**
```rust
use bollard::Docker;
use bollard::container::{ListContainersOptions, ContainerSummary, StartContainerOptions, StopContainerOptions};
use bollard::image::{ListImagesOptions, ImageSummary, CreateImageOptions, CreateImageInfo};
use bollard::API_DEFAULT_VERSION;
use futures_util::stream::TryStreamExt;
use std::default::Default;

pub struct DockerClient {
    docker: Docker,
}

impl DockerClient {
    pub fn new() -> Self {
        // 注意：根據你的系統調整 socket 路徑
        let docker = Docker::connect_with_unix(
            "/var/run/docker.sock",  // Linux 路徑
            120, // 超時時間（秒）
            API_DEFAULT_VERSION,
        )
        .expect("Failed to connect to Docker");
        Self { docker }
    }

    pub async fn list_containers(&self, all: bool) -> Result<Vec<ContainerSummary>, bollard::errors::Error> {
        let options = Some(ListContainersOptions {
            all,
            ..Default::default()
        });
        let containers = self.docker.list_containers(options).await?;
        Ok(containers)
    }

    pub async fn list_images(&self) -> Result<Vec<ImageSummary>, bollard::errors::Error> {
        let options = Some(ListImagesOptions {
            all: true,
            ..Default::default()
        });
        let images = self.docker.list_images(options).await?;
        Ok(images)
    }

    pub async fn start_container(&self, container_name: &str) -> Result<(), bollard::errors::Error> {
        self.docker
            .start_container(container_name, None::<StartContainerOptions<String>>)
            .await?;
        Ok(())
    }

    pub async fn stop_container(&self, container_name: &str) -> Result<(), bollard::errors::Error> {
        let options = Some(StopContainerOptions { t: 30 });
        self.docker.stop_container(container_name, options).await?;
        Ok(())
    }

    pub async fn pull_image(&self, image_name: &str) -> Result<(), bollard::errors::Error> {
        let options = Some(CreateImageOptions {
            from_image: image_name,
            ..Default::default()
        });
        let mut stream = self.docker.create_image(options, None, None);
        while let Some(msg) = stream.try_next().await? {
            if let Some(status) = msg.status {
                println!("{}", status);
            }
        }
        Ok(())
    }
}
```

### 主應用程式

**src/main.rs:**
```rust
mod cli;
mod docker;

use clap::Parser;
use cli::{Cli, Command, ListCommands};
use docker::DockerClient;

#[tokio::main]
async fn main() {
    // 解析 CLI 輸入
    let args = Cli::parse();
    let docker_client = DockerClient::new();

    // 路由並處理帶有非同步 Docker 呼叫的命令
    match args.command {
        Command::List { list_command } => match list_command {
            ListCommands::Containers { all } => {
                println!("列出容器:");
                match docker_client.list_containers(all).await {
                    Ok(containers) => {
                        for container in containers {
                            println!(
                                "{}\t{}\t{}",
                                container.id.unwrap_or_default(),
                                container.names.unwrap_or_default().join(","),
                                container.status.unwrap_or_default()
                            );
                        }
                    },
                    Err(e) => eprintln!("列出容器時出錯: {}", e),
                }
            },
            ListCommands::Images => {
                println!("列出鏡像:");
                match docker_client.list_images().await {
                    Ok(images) => {
                        for image in images {
                            println!("{}\t{}", image.id, image.repo_tags.join(","));
                        }
                    },
                    Err(e) => eprintln!("列出鏡像時出錯: {}", e),
                }
            },
        },
        Command::Start { container_name } => {
            println!("啟動容器: {}", container_name);
            match docker_client.start_container(&container_name).await {
                Ok(_) => println!("容器啟動成功"),
                Err(e) => eprintln!("啟動容器時出錯: {}", e),
            }
        },
        Command::Stop { container_name } => {
            println!("停止容器: {}", container_name);
            match docker_client.stop_container(&container_name).await {
                Ok(_) => println!("容器停止成功"),
                Err(e) => eprintln!("停止容器時出錯: {}", e),
            }
        },
        Command::Pull { image_name } => {
            println!("拉取鏡像: {}", image_name);
            match docker_client.pull_image(&image_name).await {
                Ok(_) => println!("鏡像拉取成功"),
                Err(e) => eprintln!("拉取鏡像時出錯: {}", e),
            }
        },
    }
}
```

### 使用範例

```bash
# 建置專案
cargo build

# 列出運行中的容器
cargo run -- list containers

# 列出所有容器（包括已停止的）
cargo run -- list containers --all

# 列出鏡像
cargo run -- list images

# 啟動容器
cargo run -- start my_container

# 停止容器
cargo run -- stop my_container

# 拉取鏡像
cargo run -- pull nginx:latest
```

---

## 最佳實踐與命令總覽

### Rust 偵錯最佳實踐

| 實踐 | 描述 | 範例 |
|------|------|------|
| 分級使用工具 | println! 用於快速測試，log 用於生產環境 | `info!("User {} logged in", user_id)` |
| 適當的日誌等級 | 根據重要性使用不同等級 | error! > warn! > info! > debug! > trace! |
| 避免敏感資料 | 生產環境中不要記錄敏感資訊 | 避免 `debug!("Password: {}", password)` |
| 防禦性程式設計 | 使用 assert! 和錯誤處理 | `assert!(!data.is_empty())` |
| 單元測試 | 為修復的錯誤編寫測試 | `#[test] fn test_edge_case() {}` |

### 常用偵錯命令總覽

```bash
# 編譯與執行
cargo build                    # 開發建置（帶偵錯資訊）
cargo build --release         # 發布建置（最佳化）
cargo run                     # 編譯並執行
cargo test                    # 執行測試

# 偵錯工具
rust-lldb target/debug/app    # 使用 LLDB 偵錯
rust-gdb target/debug/app     # 使用 GDB 偵錯
cargo expand                  # 展開巨集（需要 cargo-expand）

# 日誌控制
RUST_LOG=debug cargo run      # 設定日誌等級
RUST_LOG=info,myapp=debug cargo run  # 模組特定日誌

# 程式碼品質
cargo clippy                  # 靜態分析
cargo fmt                     # 程式碼格式化
```

### CLI 開發最佳實踐

```rust
// 1. 提供清晰的幫助文檔
#[derive(Parser)]
#[command(
    name = "myapp",
    about = "一個有用的應用程式",
    long_about = "詳細的描述...",
    version = "1.0.0"
)]
struct Cli { /* ... */ }

// 2. 使用枚舉處理錯誤
#[derive(Debug)]
enum AppError {
    DockerError(bollard::errors::Error),
    IoError(std::io::Error),
    ConfigError(String),
}

// 3. 實現用戶友好的錯誤訊息
impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            AppError::DockerError(e) => write!(f, "Docker 錯誤: {}", e),
            AppError::IoError(e) => write!(f, "IO 錯誤: {}", e),
            AppError::ConfigError(e) => write!(f, "配置錯誤: {}", e),
        }
    }
}

// 4. 適當的非同步處理
#[tokio::main]
async fn main() -> Result<(), AppError> {
    // 應用程式邏輯
    Ok(())
}
```

### 效能與安全考量

```rust
// 在生產環境中限制日誌輸出
#[cfg(not(debug_assertions))]
fn setup_production_logging() {
    env_logger::Builder::new()
        .filter_level(log::LevelFilter::Info)
        .init();
}

// 安全的錯誤處理
fn safe_file_operation(path: &str) -> Result<String, AppError> {
    std::fs::read_to_string(path)
        .map_err(AppError::IoError)
}

// 資源清理
impl Drop for DockerClient {
    fn drop(&mut self) {
        // 清理資源
    }
}
```

## 總結

本筆記提供了 Rust 偵錯和 CLI 工具開發的完整指南，從基礎的 `println!` 偵錯到複雜的 Docker CLI 工具開發。關鍵要點包括：

1. **分層偵錯策略**：從簡單輸出到專業工具逐步深入
2. **結構化日誌**：使用 `log` + `env_logger` 進行可維護的日誌記錄
3. **現代 CLI 開發**：利用 `clap` 建立功能豐富的命令列介面
4. **系統整合**：透過 `bollard` 等庫與系統服務互動
5. **錯誤處理**：實現健壯的錯誤處理和用戶友好的錯誤訊息

這些工具和實踐將幫助你建立更可靠、更易維護的 Rust 應用程式。