# 作業系統筆記：程式與行程、行程狀態與排程

## 程式 (Program) vs 行程 (Process)

### 程式 (Program)
- 儲存在硬碟中的可執行檔案（如 `.exe` 檔案）
- **被動實體 (Passive Entity)**
- 範例：`Google Chrome.exe`、`MS-WORD.exe`
- 本身不執行任何操作，只能用來產生行程

### 行程 (Process)
- 當用戶開啟程式時，系統會創建一個行程
- **主動實體 (Active Entity)**
- 一個程式可產生多個行程（例：多個 Chrome 視窗）
- 行程包含：
  - 程式碼本身
  - **堆疊 (Stack)**：函數呼叫追蹤
  - **堆積 (Heap)**：動態記憶體分配
  - 靜態與全域變數

---

## 行程狀態 (Process States)

### 主要狀態
- **新建 (New)**：剛被創建
- **就緒 (Ready)**：已在 RAM，等待 CPU 或 I/O
- **執行 (Running)**：CPU 正在執行
- **I/O/阻塞 (I/O State / Blocked)**：進行輸入輸出，等待完成
- **終止 (Terminated)**：行程結束並移出 RAM

### 額外狀態
- **掛起就緒 (Suspend Ready)**
- **掛起等待 (Suspend Wait / Suspend I/O)**

---

## 多工程度 (Degree of Multiprogramming)
- **定義**：RAM 中可容納的最大行程數量
- **公式**：`多工程度 = RAM大小 / 單個行程大小`

### 範例
- RAM 大小：4GB = 2³² Bytes
- 行程大小：4KB = 2¹² Bytes  
- 多工程度 = 2³² / 2¹² = 2²⁰ = **1,048,576 個行程**

---

## 作業系統類型

1. **批次處理系統 (Batch OS)**
   - 多工程度 = 1
   - 當行程進行 I/O 時，CPU 閒置 → 效率低
   - 已少見

2. **多工系統 (Multiprogramming OS)**
   - RAM 可容納多個行程
   - I/O 與 CPU 可交錯執行 → **並行處理 (Concurrent Processing)**
   - 提高 CPU 利用率

3. **多處理器系統 (Multiprocessing OS)**
   - 有多個 CPU
   - 可實現 **平行處理 (Parallel Processing)**
   - 成本高，但現代多核處理器普遍採用

---

## CPU 效率
- **公式**：`效率 = 有用時間 / 總時間`
- 多工系統 → 減少 CPU 閒置時間 → 提升效率

---

## 行程控制區塊 (PCB - Process Control Block)
每個行程的描述資訊，包含：
- **行程ID (Process ID)**：唯一編號
- **程式計數器 (Program Counter)**：記錄下次要執行的指令位置
- **通用暫存器 (General Purpose Registers)**：行程暫存器值
- **開啟檔案清單**：記錄行程已開啟的檔案
- **開啟裝置清單**：記錄使用的 I/O 裝置
- **保護資訊**：避免存取其他行程的記憶體空間

---

## 排程演算法 (Scheduling Algorithms)

### 功能
- 決定多個行程使用 CPU 的順序
- 由 **排程器 (Scheduler)** 控制

### 常見演算法
1. **先到先服務 (FCFS, First Come First Serve)**
   - 先進入 RAM 的行程先執行

2. **最短工作優先 (SJF, Shortest Job First)**
   - 需要最少 CPU 時間的行程優先
   - 可能 **發生搶佔 (Preemption)**

### 搶佔範例
- 當高優先權行程進入 RAM → 當前執行行程被暫停
- 系統會保存 **程式計數器與暫存器值** → 以便恢復

---

## 記憶體分配
- **堆疊 (Stack)**：函數呼叫、區域變數（向下增長）
- **堆積 (Heap)**：動態記憶體分配（向上增長）
- 空間大小依程式需求而定

---

## 重要概念總結
- **程式 = 被動檔案，行程 = 主動執行實體**
- **多工系統**：在 RAM 中保持多個行程以提高 CPU 效率
- **排程演算法**：決定行程使用 CPU 的順序
- **PCB**：保存行程的執行狀態，支援多工處理


# 作業系統行程管理筆記

## 1. Process 與 PCB (Process Control Block)
- **每個行程 (Process)** 都有一個 **PCB**。
- **PCB 內容**：  
  - Process ID  
  - 程式計數器 (Program Counter)  
  - 已開啟的檔案清單  
  - CPU 暫存器資訊  
  - 狀態 (Ready、Waiting、Running …)  
  - 優先權 (Priority)  
- **Context (上下文)**：一個行程的 PCB + 所有屬性 → 稱為該行程的「上下文」。  

---

## 2. 時間相關概念
### (1) Point-in-Time（時間點）
- 特定的一個時間點，例如：
  - **到達時間 (Arrival Time)**：程式進入 RAM 的時間  
  - **完成時間 (Completion Time)**：程式完成並退出 RAM 的時間  

### (2) Duration-in-Time（時間區間）
- 一段持續的時間，例如：
  - **週轉時間 (Turnaround Time, TAT)**  
    - 定義：程式從到達 RAM 到完成執行的總時間  
    - 公式：  
      - `TAT = 完成時間 - 到達時間`  
      - `TAT = CPU Burst Time + I/O Time + Waiting Time`  
    - 單位：小時、分鐘（而不是 AM/PM）  
  - **等待時間 (Waiting Time)**  
    - 定義：程式在 RAM 中閒置、沒有執行 CPU 也沒有做 I/O 的時間總和  
    - 計算方式：累積「排隊等 CPU」的時間區間  
  - **I/O 時間 (I/O Time)**  
    - 定義：程式進入 RAM 後，進行 I/O 操作所花的時間  
  - **回應時間 (Response Time)**  
    - 定義：程式從到達 RAM 到第一次獲得 CPU 執行的時間  
    - （詳細例子後面才會容易理解）

---

## 3. Process 狀態轉換
- **New**：程式被建立  
- **Ready**：在 RAM 等待 CPU  
- **Running**：正在 CPU 上執行  
- **Waiting / Blocked (I/O)**：等待 I/O 完成  
- **Terminated**：完成後被移出 RAM  

---

## 4. 排程器 (Schedulers)
### (1) 長程排程器 (Long-Term Scheduler)
- 決定哪些「新建立」的程式能被載入 RAM。  
- 目的：控制系統中同時存在的行程數。  

### (2) 短程排程器 (Short-Term Scheduler, 又稱 Scheduler)
- 決定 **在 Ready Queue 裡，誰先用 CPU**。  
- 負責「CPU 排程」。  

### (3) 中程排程器 (Medium-Term Scheduler)
- 當 RAM 已滿，但有高優先權程式需要進來：  
  - **Swap out**：把低優先權程式移回 Hard Disk。  
  - **Swap in**：把高優先權程式載入 RAM。  
- 達成 **Swapping (換入換出)**。  

---

## 5. Context Switching（上下文切換）
- 當高優先權行程到來 → 目前行程被中斷 (Preempted)。  
- OS 會 **保存當前行程的 Context (PCB + 屬性)**，以便之後能從中斷處繼續。  
- 然後 CPU 開始執行高優先權行程。  

---

## 6. 排程演算法 (Scheduling Algorithms)
### (1) 非搶先式 (Non-preemptive)
- 一旦行程開始執行，直到完成前 **不會被中斷**。  
- 即使新來的行程優先權更高，也要等目前的行程結束。  

### (2) 搶先式 (Preemptive)
- 行程執行途中，若有更高優先權行程到來 → **會中斷目前行程**。  
- 範例：  
  - P1 正在執行，P4 進來且優先權比 P1 高 → P1 被中斷，CPU 轉去執行 P4。  

---

## 7. CPU 排程只考慮 **Ready Queue**
- CPU 排程演算法 **只挑選 Ready 狀態的行程**。  
- I/O 狀態 (Blocked) 的行程 **不會被選中**，因為它需要等 I/O 完成。  

---

# 總結
- **PCB + Attributes = Context**  
- **Point-in-time** → Arrival / Completion time  
- **Duration-in-time** → TAT / Waiting Time / I/O Time / Response Time  
- **Schedulers**：  
  - Long-Term：決定哪些行程進 RAM  
  - Short-Term：決定誰先用 CPU  
  - Medium-Term：做 Swapping，維護高優先權行程  
- **Scheduling 演算法**：分 Preemptive & Non-preemptive  
- **CPU Scheduling 僅適用於 Ready State**  

# Shortest Job First (SJF) Scheduling Algorithm

## 1. 理論說明
- **SJF 定義**：  
  - 在已到達 (Arrived) 的行程中，**選擇最短 CPU Burst Time 的行程**來執行。  
  - **Burst Time = Execution Time**（同義）。  
- **屬性**：  
  - **非搶先式 (Non-preemptive)**：一旦行程開始執行，直到結束才會切換。  
  - **屬於 Priority-based Scheduling**：  
    - Burst Time 越短 → 優先權越高  
    - Burst Time 越長 → 優先權越低  
- **缺點**：可能造成 **Starvation**（長工作被長期延遲）。  

---

## 2. 計算公式
- **Completion Time (CT)** = 行程完成的時間點  
- **Turnaround Time (TAT)** = `CT – AT`  
- **Waiting Time (WT)** = `TAT – BT` （假設沒有 I/O）  
- **Schedule Length (SL)** = `最後完成時間 – 最早到達時間`  
- **Throughput** = `完成的行程數 ÷ SL`

---

## 3. 範例一
### 已知：
| Process | Arrival Time (AT) | Burst Time (BT) |
|---------|--------------------|-----------------|
| P1      | 2                 | 3               |
| P2      | 3                 | 2               |
| P3      | 4                 | 3               |
| P4      | 6                 | 1               |
| P5      | 8                 | 2               |

---

### (1) Gantt Chart
0 2 5 7 8 10 13
| |---P1---|---P2---|P4|--P5--|----P3----|

- 0–2：CPU Idle  
- P1：2 → 5  
- P2：5 → 7  
- P4：7 → 8  
- P5：8 → 10  
- P3：10 → 13  

---

### (2) Completion Time (CT)
- P1 = 5  
- P2 = 7  
- P3 = 13  
- P4 = 8  
- P5 = 10  

---

### (3) Turnaround Time (TAT = CT – AT)
- P1 = 5 – 2 = 3  
- P2 = 7 – 3 = 4  
- P3 = 13 – 4 = 9  
- P4 = 8 – 6 = 2  
- P5 = 10 – 8 = 2  

**平均 TAT = (3 + 4 + 9 + 2 + 2) ÷ 5 = 20 ÷ 5 = 4**

---

### (4) Waiting Time (WT = TAT – BT)
- P1 = 3 – 3 = 0  
- P2 = 4 – 2 = 2  
- P3 = 9 – 3 = 6  
- P4 = 2 – 1 = 1  
- P5 = 2 – 2 = 0  

**平均 WT = (0 + 2 + 6 + 1 + 0) ÷ 5 = 9 ÷ 5 = 1.8**

---

### (5) Schedule Length & Throughput
- **Schedule Length** = `13 – 2 = 11`  
- **Throughput** = `5 ÷ 11 ≈ 0.454` (processes per unit time)

---

## 4. 範例二
### 已知：
| Process | Arrival Time (AT) | Burst Time (BT) |
|---------|--------------------|-----------------|
| P1      | 1                 | 7               |
| P2      | 2                 | 5               |
| P3      | 3                 | 1               |
| P4      | 4                 | 2               |
| P5      | 5                 | 8               |

---

### (1) Gantt Chart
0 1 8 9 11 16 24
| |----P1----|P3|--P4--|----P2----|--------P5--------|
- 0–1：CPU Idle  
- P1：1 → 8  
- P3：8 → 9  
- P4：9 → 11  
- P2：11 → 16  
- P5：16 → 24  

---

### (2) Completion Time (CT)
- P1 = 8  
- P2 = 16  
- P3 = 9  
- P4 = 11  
- P5 = 24  

---

### (3) Turnaround Time (TAT = CT – AT)
- P1 = 8 – 1 = 7  
- P2 = 16 – 2 = 14  
- P3 = 9 – 3 = 6  
- P4 = 11 – 4 = 7  
- P5 = 24 – 5 = 19  

**平均 TAT = (7 + 14 + 6 + 7 + 19) ÷ 5 = 53 ÷ 5 = 10.6**

---

### (4) Waiting Time (WT = TAT – BT)
- P1 = 7 – 7 = 0  
- P2 = 14 – 5 = 9  
- P3 = 6 – 1 = 5  
- P4 = 7 – 2 = 5  
- P5 = 19 – 8 = 11  

**平均 WT = (0 + 9 + 5 + 5 + 11) ÷ 5 = 30 ÷ 5 = 6**

---

### (5) Schedule Length & Throughput
- **Schedule Length** = `24 – 1 = 23`  
- **Throughput** = `5 ÷ 23 ≈ 0.217` (processes per unit time)

---

# ✅ 總結
- **SJF 特點**：  
  - 非搶先式、屬於 Priority Scheduling  
  - 對短作業友好，但可能造成長作業飢餓 (Starvation)  
- **計算流程**：  
  1. 畫 Gantt Chart  
  2. 算 Completion Time  
  3. 算 Turnaround Time (CT – AT)  
  4. 算 Waiting Time (TAT – BT)  
  5. 算 Schedule Length & Throughput  



# CPU 排程演算法筆記

## 1. FCFS (First Come First Serve)

### 特點
- **非搶先式 (Non-preemptive)** 排程
- 根據 **到達時間 (Arrival Time)** 排序  
- **先來先服務**，完全不考慮 burst time  
- 與 **排隊櫃台** 類似 (像銀行或售票系統)

### 公式
- **Turnaround Time (TAT)**  
TAT = Completion Time − Arrival Time

- **Waiting Time (WT)**  
WT = TAT − Burst Time
- **Response Time (RT)**  
RT = WT (因為非搶先式，所以 RT = WT)

### 範例  
假設有 3 個 Process：  

| Process | Arrival Time | Burst Time |
|---------|--------------|------------|
| P1      | 0            | 5          |
| P2      | 1            | 3          |
| P3      | 2            | 8          |

#### Gantt Chart
0 --- P1(5) --- 5 --- P2(3) --- 8 --- P3(8) --- 16

#### 計算
- P1: CT = 5,  TAT = 5-0=5,  WT=5-5=0  
- P2: CT = 8,  TAT = 8-1=7,  WT=7-3=4  
- P3: CT = 16, TAT = 16-2=14, WT=14-8=6  

👉 平均 TAT = (5+7+14)/3 = 8.67  
👉 平均 WT  = (0+4+6)/3 = 3.33  

---

## 2. SRTF (Shortest Remaining Time First)

### 特點
- **搶先式 (Preemptive)** 排程
- 是 **SJF (Shortest Job First)** 的搶先版本
- 在任何時刻：  
  - CPU 選擇 **剩餘執行時間最短**的 Process  
  - 若新進來的 Process burst time 更短 → 會 **中斷 (preempt)** 目前執行中的 Process

### 公式
- **Turnaround Time (TAT)**  
TAT = Completion Time − Arrival Time

- **Waiting Time (WT)**  


WT = TAT − Burst Time

- **Response Time (RT)**  
RT = 第一次獲得 CPU 的時間 − Arrival Time

### 範例  
假設有 3 個 Process：  

| Process | Arrival Time | Burst Time |
|---------|--------------|------------|
| P1      | 0            | 7          |
| P2      | 2            | 4          |
| P3      | 4            | 1          |

#### Gantt Chart
0 --- P1(2) --- 2 --- P2(2) --- 4 --- P3(1) --- 5 --- P2(2) --- 7 --- P1(5) --- 12

#### 計算
- P1: CT=12, TAT=12-0=12, WT=12-7=5, RT=0-0=0  
- P2: CT=7,  TAT=7-2=5,  WT=5-4=1,  RT=2-2=0  
- P3: CT=5,  TAT=5-4=1,  WT=1-1=0,  RT=4-4=0  

👉 平均 TAT = (12+5+1)/3 = 6  
👉 平均 WT  = (5+1+0)/3 = 2  

---

## 3. FCFS vs SRTF 差異比較表

| 特性                | FCFS (First Come First Serve) | SRTF (Shortest Remaining Time First) |
|---------------------|-------------------------------|---------------------------------------|
| 類型                | 非搶先式 (Non-preemptive)     | 搶先式 (Preemptive)                   |
| 排程依據            | 到達時間 (Arrival Time)       | 剩餘時間最短的 process                |
| 公平性              | 高（先來先服務）             | 不公平（長任務可能被餓死 starvation）  |
| Response Time (RT) | 等於 Waiting Time (RT=WT)     | RT ≤ WT                              |
| 適用情境            | 批次作業系統，簡單公平        | 即時系統，需要快速響應                |
| 缺點                | 長任務導致短任務等待很久      | 可能導致 starvation，排程開銷大        |


# CPU Scheduling 筆記 (FCFS, SJF, SRTF)

## 1. Starvation 問題

### 定義
- **Starvation**：某個 process 在 Ready Queue 中可能 **無限期 (indefinitely)** 等待 CPU。
- ⚠️ 注意：
  - **Indefinitely** = 沒有明確的上限時間，可能等很久才輪到  
  - **Infinitely** = 永遠不會輪到  

### 發生原因
- 出現在 **Priority-based Scheduling** 演算法中。
- 當總是有更高優先權 (或更短 burst time) 的 process 到達時，低優先權的 process 可能一直被延後，導致 starvation。

---

## 2. Convoy Effect 問題

### 定義
- **Convoy Effect**：小的 process 必須等待一個大的 process 完成後，才能獲得 CPU。
- **結果**：增加 **Average Waiting Time** 與 **Turnaround Time**。

### 例子
- 超市排隊：  
  - 一個顧客買了很多商品，結帳需要很久。  
  - 後面只有一件商品的顧客，卻得等前面的大顧客結束後才能結帳。

---

## 3. 演算法比較表

| 演算法 | 是否 Preemptive | Starvation | Convoy Effect | Throughput | 實作難度 |
|--------|----------------|------------|---------------|------------|----------|
| **FCFS** (First Come First Serve) | ❌ Non-preemptive | ❌ 不會發生 | ✅ 會發生 | ❌ 較低 | ✅ 容易實作 (只需 Arrival Time) |
| **SJF** (Shortest Job First) | ❌ Non-preemptive | ✅ 可能發生 | ✅ 會發生 | ✅ 較高 (比 FCFS 好) | ❌ 難實作 (需預知 Burst Time) |
| **SRTF** (Shortest Remaining Time First) | ✅ Preemptive | ✅ 可能發生 | ❌ 不會發生 | ✅ 更高 (比 SJF 好) | ❌ 難實作 (需持續知道剩餘 Burst Time) |

---

## 4. Throughput 比較

- **Throughput** = 每單位時間完成的 processes 數量  
- 效率排序：
SRTF > SJF > FCFS

### 原因
- **FCFS**：先到先服務 → 可能先執行大 process → throughput 低  
- **SJF**：選最短 burst time (among arrived processes) → throughput 較高  
- **SRTF**：允許 preemption → 即使大 process 執行中，有更短的 process 到達也會切換 → throughput 最高  

---

## 5. 總結

- **Starvation**：  
- 所有 **Priority-based** (SJF, SRTF) 都可能發生  
- **FCFS** 不會發生

- **Convoy Effect**：  
- **FCFS、SJF** 會發生  
- **SRTF** 不會發生

- **Throughput**：  
- `SRTF > SJF > FCFS`

- **Practicality**：  
- **FCFS**：容易實作  
- **SJF、SRTF**：難實作 (需知道 burst time)

---
