# 記憶體管理基礎筆記

## 記憶體層級
- **暫存器 (Registers)**：最靠近CPU，速度最快
- **RAM (隨機存取記憶體)**：通常簡稱為"記憶體"
- **硬碟 (Hard Disk)**：通常簡稱為"磁碟"
- **快取記憶體 (Cache)**：本課程不討論

## 基本概念

### 什麼是記憶體？
- 傳統上"記憶體"指的是RAM
- "磁碟"指的是硬碟

### CPU與記憶體的互動
- CPU從RAM讀取資料到暫存器進行處理
- 暫存器是電腦中最快的記憶體
- 暫存器大小通常為1個字(word)

### 記憶體中的內容
- **指令 (Instructions)**：程式的一部分
- **資料 (Data)**：數字、文字、影像、音訊等
- 所有內容都以二進位(0和1)形式儲存

## 記憶體定址

### 字(Word)的概念
- RAM被劃分為多個字
- 每個字包含一個指令或資料
- 字的大小通常是2的冪次方(4位元組、8位元組等)

### 定址方式
- 每個字都有一個地址
- 地址從0開始
- 地址用二進位表示
- 若有2^m個字，需要m位元來定址

### 匯流排(Bus)
- **地址匯流排**：傳送地址
- **資料匯流排**：傳送資料
- 用於CPU與RAM之間的通信

## 位址空間
### 實體位址空間 (Physical Address Space)
- RAM中所有地址的集合

### 邏輯位址空間 (Logical Address Space)
- 行程中所有地址的集合

## 記憶體配置
### 連續配置 (Contiguous Allocation)
- 行程的所有邏輯地址都對應到RAM中的連續實體地址

### 非連續配置 (Non-Contiguous Allocation)
- 行程的邏輯地址分散在RAM的不同位置

## 固定分割 (Fixed Partitioning)

### 特點
- 也稱為靜態分割
- RAM被預先劃分為固定大小的分割區
- 每個分割區只能容納一個行程

### 缺點
1. **內部碎片 (Internal Fragmentation)**
   - 行程大小小於分割區大小時，剩餘空間浪費
   
2. **行程大小受限**
   - 最大行程大小受限於最大分割區大小
   
3. **多工程度受限**
   - 同時執行的行程數受限於分割區數量

### 優點
- 沒有外部碎片問題

## 可變分割 (Variable Partitioning)

### 特點
- 也稱為動態分割
- 根據行程大小動態分配記憶體
- 不預先劃分分割區

### 優點
1. 沒有內部碎片問題
2. 行程大小只受限於RAM總大小
3. 多工程度不受限

### 缺點
- **外部碎片 (External Fragmentation)**
  - 有足夠的總空間，但沒有足夠的連續空間來配置行程

## 配置演算法

### 首次配置 (First-Fit)
- 從開頭開始掃描，找到第一個足夠大的空間就配置
- 最佳情況下搜尋時間短

### 下次配置 (Next-Fit)
- 從上次配置結束的位置開始掃描
- 與First-Fit類似，但起始點不同

### 最佳配置 (Best-Fit)
- 掃描整個記憶體，找到最適合(最小)的足夠空間
- 缺點：可能產生很多小碎片

### 最差配置 (Worst-Fit)
- 掃描整個記憶體，找到最大的足夠空間
- 優點：減少小碎片的產生

## 演算法比較

| 演算法 | 搜尋方式 | 優點 | 缺點 |
|--------|----------|------|------|
| First-Fit | 從頭開始找第一個符合的 | 搜尋快 | 可能產生外部碎片 |
| Next-Fit | 從上次結束處開始找 | 搜尋快 | 可能產生外部碎片 |
| Best-Fit | 找最符合的大小 | 空間利用率高 | 產生小碎片，搜尋慢 |
| Worst-Fit | 找最大的空間 | 減少小碎片 | 搜尋慢 |

## 重要結論
- 沒有單一"最佳"演算法，效能取決於行程到達的順序
- 外部碎片是可變分割的主要問題
- 內部碎片是固定分割的主要問題
- 在實際應用中需要根據具體情況選擇合適的配置策略

# 記憶體管理中文筆記

## 1. 分區配置

記憶體配置主要分為兩大類：

### 固定分區
- **定義**：在載入任何行程之前，預先將實體記憶體劃分成多個固定大小的分區
- **分類**：
  - **等大小分區**：所有分區大小相同
  - **不等大小分區**：分區大小不同，以容納不同大小的行程
- **核心問題**：**內部碎片**
  - **成因**：當一個行程的大小小於其所屬分區的大小時，分區內未被使用的記憶體就被浪費了
  - **例子**：一個 1KB 的行程被放在一個 2KB 的分區裡，就會產生 1KB 的內部碎片

### 動態分區
- **定義**：不預先分區，而是根據行程的實際大小，動態地從記憶體中劃分出剛好大小的區塊
- **優點**：解決了**內部碎片**問題
- **核心問題**：**外部碎片**
  - **成因**：隨著行程的載入和卸載，記憶體中會散佈許多不連續的小空閒區塊
  - **影響**：降低**多工程度**，導致 CPU 效率下降

## 2. 配置演算法

### 首次配置
- 從頭掃描記憶體，找到第一個足夠大的空閒區塊就分配

### 最佳配置
- 掃描整個記憶體，找到能滿足需求的最小空閒區塊進行分配

### 下次配置
- 從上一次分配的位置開始向後掃描，找到第一個足夠大的空閒區塊

### 最差配置
- 總是分配最大的空閒區塊

**重點**：沒有一個演算法在所有情況下都是最優的，效能取決於記憶體佈局和請求順序。

## 3. 解決外部碎片的方法

### 壓縮
- **作法**：定期移動記憶體中已分配的行程，合併所有空閒區塊
- **優點**：能**完全消除**外部碎片
- **缺點**：**CPU密集型**操作，效能開銷巨大

### 分頁
- **核心思想**：放棄**連續分配**，改為**非連續分配**
- **作法**：允許行程的記憶體分散到多個不連續的實體區塊
- **優點**：從根本上避免外部碎片問題
- **代價**：引入新的管理開銷（需要維護映射表）

## 4. 二進位定址與分區概念

### 例子：4GB RAM，64個分區
- 4GB = 2³² Bytes
- 需要 32 位元地址來定址每個位元組
- 64個分區 = 2⁶，需要 **6 個位元**表示**分區編號**
- 每個分區大小 = 2³² / 2⁶ = 2²⁶ Bytes，需要 **26 個位元**表示**區塊內偏移量**
- **地址格式**：`[前6位：分區號] | [後26位：區塊內偏移]`

## 總結要點

1. **內部碎片**：發生在分區*內部*，是**已分配**但**未被使用**的記憶體
2. **外部碎片**：發生在分區*之間*，是**未分配**且**不連續**的記憶體
3. **壓縮**能解決外部碎片，但**成本高昂**
4. **分頁**透過**非連續分配**來解決外部碎片，是現代作業系統的核心技術